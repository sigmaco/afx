/*
 *          ::::::::  :::       :::     :::     :::::::::  :::::::::   ::::::::
 *         :+:    :+: :+:       :+:   :+: :+:   :+:    :+: :+:    :+: :+:    :+:
 *         +:+    +:+ +:+       +:+  +:+   +:+  +:+    +:+ +:+    +:+ +:+    +:+
 *         +#+    +:+ +#+  +:+  +#+ +#++:++#++: +#+    +:+ +#++:++#:  +#+    +:+
 *         +#+  # +#+ +#+ +#+#+ +#+ +#+     +#+ +#+    +#+ +#+    +#+ +#+    +#+
 *         #+#   +#+   #+#+# #+#+#  #+#     #+# #+#    #+# #+#    #+# #+#    #+#
 *          ###### ###  ###   ###   ###     ### #########  ###    ###  ########
 *
 *        Q W A D R O   V I D E O   G R A P H I C S   I N F R A S T R U C T U R E
 *
 *                                   Public Test Build
 *                               (c) 2017 SIGMA FEDERATION
 *                             <https://sigmaco.org/qwadro/>
 */

// This code is part of SIGMA GL/2 <https://sigmaco.org/gl>
// This software is part of Advanced Video Graphics Extensions & Experiments.

#ifndef AVX_DRAW_CONTEXT_H
#define AVX_DRAW_CONTEXT_H

/**
    Command buffers are objects used to record commands which can be subsequently submitted to a device queue for execution. 
    There are two levels of command buffers - primary command buffers, which can execute secondary command buffers, and which are submitted to queues, 
    and secondary command buffers, which can be executed by primary command buffers, and which are not directly submitted to queues.
*/
/*
    When a pipeline object is bound, any pipeline object state that is not specified as dynamic is applied to the draw context state.
    Pipeline object state that is specified as dynamic is not applied to the draw context state at this time.
    Instead, dynamic state can be modified at any time and persists for the lifetime of the draw context, 
    or until modified by another dynamic state setting command, 
    or made invalid by another pipeline bind with that state specified as static.
*/

// COMMAND BATCH --- a group of records processed as a single unit, usually without input from a user.

/*
    Rolling a context; switching or cycling between contexts.

    In Qwadro, where we manage multiple rendering contexts, to "roll a context" might mean:
    switching from one context to another in a sequence or loop.
    For example, in multi-threaded rendering, you may have several contexts or command buffers to avoid synchronization issues.
    "Rolling" mean rotating through a set of contexts to reuse them safely (like a ring buffer).
    Similar to double or triple buffering, but for command buffers, descriptors, or staging resources.

    Rotating between frame contexts.

    Engines often create per-frame "contexts" (bundles of transient data/resources). Something like:
    
    ```c
    struct FrameContext {
        VkCommandBuffer cmdBuffer;
        VkSemaphore imageAvailable;
        VkFence renderFinished;
        // ...
    };
    FrameContext frames[3]; // triple buffering
    ```
    
    Here, rolling the context is equal to moving to the next frame context in the ring.

    ```c
    currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
    FrameContext* context = &frames[currentFrame];
    ```

    Saving/restoring state ("context").
    In persistent contexts, rolling a context might mean saving the current state and restoring another one, 
    like rolling a coroutine or fiber context.
*/

#include "qwadro/draw/avxDrawing.h"
#include "qwadro/draw/avxProvision.h"
#include "qwadro/draw/afxDrawBridge.h"

typedef enum avxScheduleFlag
{
    // specifies that each recording of the command stream will only be submitted once, 
    // and the command stream will be reset and recorded again between each submission.
    avxScheduleFlag_ONCE,

    // specifies that a secondary command stream is considered to be entirely inside a draw scope.
    // If this is a primary command stream, then this bit is ignored.
    avxScheduleFlag_DRAW_SCOPED,

    // specifies that a command stream can be resubmitted to any queue of the same queue family while it is in the pending state, 
    // and recorded into multiple primary command streams.
    avxScheduleFlag_SIMULTANEOUS,
    // NOTE: Are ONCE and SIMULTANEOUS mutually exclusive? How AVX will queue it?
} avxScheduleFlags;

typedef enum avxContextFlag
{
    // The command streams generated by the context are expected to be ephemeral, meaning that they will become invalidated in a relatively short timeframe. 
    // This flag is intended to be used by the implementation to optimize memory management.
    avxContextFlag_TRANSIENT    = AFX_BITMASK(0),
    // The command streams generated by the context are NOT able to be individually reset.
    avxContextFlag_MONOLITHIC   = AFX_BITMASK(1),
    // The command streams generated by the context are protected.
    avxContextFlag_PROTECTED    = AFX_BITMASK(2),
} avxContextFlags;

AFX_DEFINE_STRUCT(avxContextInfo)
{
    avxContextFlags flags;
    afxDrawFn       caps;
    // The execution unit (in Mantle, this refers to a specific GPU hardware unit or execution engine).
    // NOTE 1 mentions that, in Mantle, unlike Vulkan, you specify queue capabilities rather than the execution unit index.
    afxMask         exuMask;
    afxBool         once;
    afxBool         deferred;
    afxUnit         binCnt;
    afxUnit         rollCnt;
};

/*
    The AvxAcquireDrawContexts() function allocates multiple draw contexts (which could be command buffers
    or command contexts) for recording drawing commands for a specified draw system.

    This function allocates @cnt draw contexts (command buffers) and returns them in the @contexts[] array.
    If the allocation of any of the draw contexts fails, all successfully allocated draw contexts are freed and set to NIL.
    The function returns an error code if any allocation fails.
*/
// NOTE 1: In Mantle, unlike Vulkan, we specify the queue capabilites instead of exuIdx.
// NOTE 2: In Mantle and Vulkan, we specify optimization hints (like ONE_TIME) when we starts recording a context (with a Begin() function);

AVX afxError        AvxAcquireDrawContexts
(
    // The draw system to provide the drawing contexts.
    afxDrawSystem   dsys,
    // The information specifying the operation context.
    avxContextInfo const* info,
    // The count of the draw contexts wanted to be allocated.
    afxUnit         cnt,
    // An array of draw contexts to be allocated.
    afxDrawContext  contexts[]
);

/*
    The AvxExecuteDrawCommands() function submits multiple draw commands to the devices briged to the draw system for execution.
    It allows for synchronized execution using a fence object, ensuring that commands are executed in the proper order.
    This function is useful in graphics systems where multiple command streams need to be processed,
    and synchronization between CPU and GPU tasks is required. By managing the submission through a control structure
    and using a fence for synchronization, the function ensures that commands are executed efficiently and correctly.
*/

AVX afxError        AvxExecuteDrawCommands
(
    // The draw system where the draw commands will be executed.
    afxDrawSystem   dsys,

    // The number of draw contexts to be executed.
    // This tells the function how many contexts in the @contexts array should be processed.
    afxUnit         cnt,

    // A control structure that might define various parameters related to how the draw commands are submitted, 
    // such as synchronization or execution order. This encapsulate details like submission flags, 
    // command queues, or context properties that manage how and when the draw commands are executed.
    avxSubmission   submissions[]
);

////////////////////////////////////////////////////////////////////////////////

AVX afxUnit     AvxGetCommandPort(afxDrawContext dctx);

AVX afxUnit     AvxGetCommandPool(afxDrawContext dctx);

AVX afxError        AvxExhaustDrawContext
(
    afxDrawContext  dctx,
    afxBool         freeMem
);

AVX afxError        AvxRecordDrawCommands
(
    // The draw context which the batch will be allocated from.
    afxDrawContext  dctx, 
    // A flag specifying a one-time submission batch.
    afxBool         once, 
    // A flag specifying a inlineable batch.
    afxBool         deferred, 
    // A variable to hold the unique identifier for the batch.
    afxUnit*        batchId
);

/// Reset a draw context to the initial state.
/// Any primary draw context that is in the recording or executable state and has @dctx recorded into it, becomes invalid.

AVX afxError        AvxDiscardDrawCommands
(
    afxDrawContext  dctx,
    afxBool         freeRes
);

/// Finish recording a draw context.

AVX afxError        AvxCompileDrawCommands
(
    // The draw context recording commands.
    afxDrawContext  dctx,
    // The batch which commands will be compiled into.
    afxUnit         batchId
);

/*
    The AvxRecycleDrawCommands() function recycles draw batches, releasing resources or allowing for reuse.
    This function is used to opportunistically try to recycle draw batches (potentially preserving allocations) or destroy it.

    A flag can be used to indicate whether all or most of the resources owned by the batch should be reclaimed by the system.
    If this flag is not set, then the draw batch may hold onto memory resources and reuse them when recording commands.
*/

AVX afxError        AvxRecycleDrawCommands
(
    // The draw context that holds the commands.
    afxDrawContext  dctx, 
    // The unique identifier for the draw batch.
    afxUnit         batchId, 
    // A flag that indicates whether all or most of the resources owned by the batch should be reclaimed by the system.
    afxBool         freeRes
);

AVX afxBool AvxDoesDrawCommandsExist(afxDrawContext dctx, afxUnit batchId);



AVX afxError AvxRecordDrawCommands(afxDrawContext dctx, afxBool once, afxBool deferred, afxUnit* batchId);
AVX afxError AvxDiscardDrawCommands(afxDrawContext dctx, afxBool freeRes);
AVX afxError AvxCompileDrawCommands(afxDrawContext dctx, afxUnit batchId);
AVX afxError AvxRecycleDrawCommands(afxDrawContext dctx, afxUnit batchId, afxBool freeRes);

// Resets and restarts a command bin, and make it as the active recording stream.
AVX afxError AvxCommenceDrawCommands(afxDrawContext dctx, afxUnit bin, afxBool once, afxBool deferred);

// Selects a command bin again as the active recording stream.
AVX afxError AvxResumeDrawCommands(afxDrawContext dctx, afxUnit bin);

// Embeds the commands in the specified bin into the active command stream.
AVX afxError AvxEmbedDrawCommands(afxDrawContext dctx, afxUnit bin);

// Cleans all commands in a bin, potentially liberating resources.
AVX afxError AvxPurgeDrawCommands(afxDrawContext dctx, afxUnit bin, afxBool freeRes);

// Execute will push all active primary (non-deferred) streams.

#endif//AVX_DRAW_CONTEXT_H
