/*
 *          ::::::::  :::       :::     :::     :::::::::  :::::::::   ::::::::
 *         :+:    :+: :+:       :+:   :+: :+:   :+:    :+: :+:    :+: :+:    :+:
 *         +:+    +:+ +:+       +:+  +:+   +:+  +:+    +:+ +:+    +:+ +:+    +:+
 *         +#+    +:+ +#+  +:+  +#+ +#++:++#++: +#+    +:+ +#++:++#:  +#+    +:+
 *         +#+  # +#+ +#+ +#+#+ +#+ +#+     +#+ +#+    +#+ +#+    +#+ +#+    +#+
 *         #+#   +#+   #+#+# #+#+#  #+#     #+# #+#    #+# #+#    #+# #+#    #+#
 *          ###### ###  ###   ###   ###     ### #########  ###    ###  ########
 *
 *        Q W A D R O   V I D E O   G R A P H I C S   I N F R A S T R U C T U R E
 *
 *                                   Public Test Build
 *                               (c) 2017 SIGMA FEDERATION
 *                             <https://sigmaco.org/qwadro/>
 */

// This code is part of SIGMA GL/2 <https://sigmaco.org/gl>
// This software is part of Advanced Video Graphics Extensions & Experiments.

#ifndef AVX_DRAW_CONTEXT_H
#define AVX_DRAW_CONTEXT_H

/**
    Command buffers are objects used to record commands which can be subsequently submitted to a device queue for execution. 
    There are two levels of command buffers - primary command buffers, which can execute secondary command buffers, and which are submitted to queues, 
    and secondary command buffers, which can be executed by primary command buffers, and which are not directly submitted to queues.
*/
/*
    When a pipeline object is bound, any pipeline object state that is not specified as dynamic is applied to the draw context state.
    Pipeline object state that is specified as dynamic is not applied to the draw context state at this time.
    Instead, dynamic state can be modified at any time and persists for the lifetime of the draw context, 
    or until modified by another dynamic state setting command, 
    or made invalid by another pipeline bind with that state specified as static.
*/

// COMMAND BATCH --- a group of records processed as a single unit, usually without input from a user.

/*
    Rolling a context; switching or cycling between contexts.

    In Qwadro, where we manage multiple rendering contexts, to "roll a context" might mean:
    switching from one context to another in a sequence or loop.
    For example, in multi-threaded rendering, you may have several contexts or command buffers to avoid synchronization issues.
    "Rolling" mean rotating through a set of contexts to reuse them safely (like a ring buffer).
    Similar to double or triple buffering, but for command buffers, descriptors, or staging resources.

    Rotating between frame contexts.

    Engines often create per-frame "contexts" (bundles of transient data/resources). Something like:
    
    ```c
    struct FrameContext {
        VkCommandBuffer cmdBuffer;
        VkSemaphore imageAvailable;
        VkFence renderFinished;
        // ...
    };
    FrameContext frames[3]; // triple buffering
    ```
    
    Here, rolling the context is equal to moving to the next frame context in the ring.

    ```c
    currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
    FrameContext* context = &frames[currentFrame];
    ```

    Saving/restoring state ("context").
    In persistent contexts, rolling a context might mean saving the current state and restoring another one, 
    like rolling a coroutine or fiber context.
*/

#include "qwadro/draw/avxDrawing.h"
#include "qwadro/draw/avxProvision.h"
#include "qwadro/draw/afxDrawBridge.h"

typedef enum avxCmdFlag
{
    // Commands will be submitted once only and then automatically invalidated.
    avxCmdFlag_ONCE = AFX_BITMASK(0),
    // Commands will be side-loaded (inlined) by a front context.
    avxCmdFlag_DEFERRED = AFX_BITMASK(1),
    // Commands are considered entirely inside a drawing scope (to be used by a front context).
    avxCmdFlag_SCOPED = AFX_BITMASK(2),
    // Commands will be shared across more than one DPU concurrently.
    avxCmdFlag_SHARED = AFX_BITMASK(3)
} avxCmdFlags;

typedef enum avxContextFlag
{
    // The command streams generated by the context are expected to be ephemeral, meaning that they will become invalidated in a relatively short timeframe. 
    // This flag is intended to be used by the implementation to optimize memory management.
    avxContextFlag_TRANSIENT    = AFX_BITMASK(0),
    // The command streams generated by the context are NOT able to be individually reset.
    avxContextFlag_MONOLITHIC   = AFX_BITMASK(1),
    // The command streams generated by the context are protected.
    avxContextFlag_PROTECTED    = AFX_BITMASK(2),
} avxContextFlags;

AFX_DEFINE_STRUCT(avxContextInfo)
{
    avxAptitude     caps;
    afxMask         exuMask;
    avxContextFlags flags;
    avxCmdFlags     cmdFlags;
    afxUnit         auxCnt;
    // The capacity of recycle queue.
    afxUnit         recycCap;
    void*           udd;
    afxString       tag;
};

/*
    The AvxAcquireDrawContexts() function allocates multiple draw contexts (which could be command buffers
    or command contexts) for recording drawing commands for a specified draw system.

    This function allocates @cnt draw contexts (command buffers) and returns them in the @contexts[] array.
    If the allocation of any of the draw contexts fails, all successfully allocated draw contexts are freed and set to NIL.
    The function returns an error code if any allocation fails.
*/
// NOTE 1: In Mantle, unlike Vulkan, we specify the queue capabilites instead of exuIdx.
// NOTE 2: In Mantle and Vulkan, we specify optimization hints (like ONE_TIME) when we starts recording a context (with a Begin() function);

AVX afxError AvxAcquireDrawContexts
(
    // The draw system to provide the drawing contexts.
    afxDrawSystem dsys,
    // An optional base context to provide a shared command pool.
    afxDrawContext pool,
    // The information specifying the operation context.
    avxContextInfo const* info,
    // The count of the draw contexts wanted to be allocated.
    afxUnit cnt,
    // An array of draw contexts to be allocated.
    afxDrawContext contexts[]
);

/*
    The AvxRecycleDrawContexts() function recycles draw contexts, releasing resources or allowing for reuse.
    This function is used to opportunistically try to recycle draw contexts (potentially preserving allocations) or destroy it.

    A flag can be used to indicate whether all or most of the resources owned by the context should be reclaimed by the system.
    If this flag is not set, then the draw context may hold onto memory resources and reuse them when recording commands.
*/

AVX afxError AvxRecycleDrawContexts
(
    // A flag that indicates whether all or most of the resources owned by the batch should be reclaimed by the system.
    afxBool freeRes,
    // The number of contexts to be disposed.
    afxUnit cnt,
    // The draw context that holds the commands.
    afxDrawContext contexts[]
);

/*
    The AvxExecuteDrawCommands() function submits multiple draw commands to the devices briged to the draw system for execution.
    It allows for synchronized execution using a fence object, ensuring that commands are executed in the proper order.
    This function is useful in graphics systems where multiple command streams need to be processed,
    and synchronization between CPU and GPU tasks is required. By managing the submission through a control structure
    and using a fence for synchronization, the function ensures that commands are executed efficiently and correctly.
*/

AVX afxError AvxExecuteDrawCommands
(
    // The draw system where the draw commands will be executed.
    afxDrawSystem dsys,

    // The number of draw contexts to be executed.
    // This tells the function how many contexts in the @contexts array should be processed.
    afxUnit cnt,

    // A control structure that might define various parameters related to how the draw commands are submitted, 
    // such as synchronization or execution order. This encapsulate details like submission flags, 
    // command queues, or context properties that manage how and when the draw commands are executed.
    avxSubmission submissions[]
);

////////////////////////////////////////////////////////////////////////////////

AVX afxMask AvxGetCommandPort
(
    afxDrawContext dctx
);

AVX afxDrawContext AvxGetCommandPool
(
    afxDrawContext dctx
);

/*
    Exhausting a draw context recycles all of the resources from all of the auxiliary contexts allocated from the pool context back to the pool context. All draw contexts that have been allocated from the pool context are put in the initial state.
*/

AVX afxError AvxExhaustDrawContext
(
    afxDrawContext dctx,
    afxBool freeMem
);

/*
    Reset a draw context to the initial state.
    Any primary draw context that is in the recording or executable state and has @dctx recorded into it, becomes invalid.
*/

AVX afxError AvxPrepareDrawCommands
(
    // The draw context which the batch will be allocated from.
    afxDrawContext dctx, 
    afxBool purge,
    avxCmdFlags flags
);

/*
    Finish recording a draw context.
*/

AVX afxError AvxCompileDrawCommands
(
    // The draw context recording commands.
    afxDrawContext dctx
);

#endif//AVX_DRAW_CONTEXT_H
