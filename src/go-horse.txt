Esta lista foi criada para ajudar a entender e/ou resolver problemas oriundos da qualidade do código.
Uma vez que tudo foi inicialmente prototipado com Go Horse, que é igual a forma errada só que mais rápida,
há uma caralhada de problemas.

// POSSÍVEIS PROBLEMAS

Uso de constante 4 ao invés de sizeof(type). Quando compilando em x64, tenha certeza que vai dar merda.

Quando realizando operações aritméticas sem parênteses envolvendo adição e multiplicação, o multiplicador é executado antes do adicionador, independente da ordem. Princípios de PEMDAS. Nós usamos parênteses extras para ajudar a noção.

Quando usando 'for', é possível que a variável de índice operada por 'for' não esteja sendo usada em favor do valor total.

Quando houver erros a respeito da alocação de memória em si, como corrupção anômala, é provável que haja transbordo em operações de cópia sem controle de tamanho, como população de strings esperando por um valor nulo.

Evite usar union's para converter valores. O compilador pode arranjar os dados com alinhamentos diferentes.

Quando usando afxArray's (mas pode ser qualquer alocação), tipos que se auto-referenciem, tais como afxString e afxLinkage, terão suas referêncais quebradas em caso de realocação onde o buffer mude de endereço.

Quando a afxChain começa por first linkage, avança-se com obtendo o prêvio linkage.

Usar array de float em lugar de array de double.

Processar empty string como zero-terminated string. Ignorar o tamanho e já partir para o ponteiro.

Loop dentro de loop usando a mesma variável de controle. Exemplo: i, j, etc.
warning : declaration shadows a local variable [-Wshadow]

Float sendo convertido para int e então para float. Principalmente fatores.

Ints sendo encapsulados em ints menores. Principalmente int array para structured int16/8.

Retornando referências para valores armazenados na call stack. Strucs, por exemplo.

Ao usar high-color (16-bit) video mode, Intel drivers doesn't provide WGL extensions, causing DPU creation failure.

Device-dependent classes sendo registradas com sizeof() básico devida a cópia da standard implementation.

Ponteiro sendo passado como pointero-ad-pointero.

Depth/stencil buffer não criado em operações com depth test.

0xC000001D: Illegal Instruction --- CPU doesn't support instructions such as AVX2.

0xC0000005: Access violation reading location 0x00000000 caused by SIMD-aligned variables will be a issue with the "memory block" not being allocated with SIMD alignment.

Wrong indexation counter inside array element accessor. Ex.: [idx++] // Increase before this access.

Allocated memory data corruption occurying after the first iteration may be caused by the *counter* missing the sizeof(type).

If the frame image is blinking, one frame drawn and one or more frame not drawn (just clean), your present call is not waiting for DPU work readiness.

// POSSÍVEIS ABORDAGENS

NORM#1 O Qwadro não mais vai tentar evitar erros internos, apenas em entrada e saída de dados. O Qwadro apenas vai tentar informar argumentos inválidos. É responsabilidade do programador a resiliência e qualidade do código.

NORM#2 Quando uma operação é feita sob uma offset e um determinado range, deve usar tais termos. Se for operações de cópia correlativas, prefira os termos Input/Output para copy into e copy out.

NORM#3 Quando uma operação é feita sob uma source com parâmetros de precisão, tais como offset, range e stride, tais parâmetros devem ser posicionados após o parâmetro de alimentação para clareza.

Draw system poderia arranjar implementation-dependent draw contexts e dispô-los para os draw context agnósticos.

Eventos de objetos-filho deveriam ser enviados ao parente apenas.

Criar um objeto 'afxHandle*' segurando um ponteiro para um afxHandle. Referências poderiam ser movidas para o afxHandle*, talvez.
O afxHandle* seria um conector de afxHandle's tal como um binding. Venceria uma limitação de afxLinkage.

// CONVENÇÃO DE NOMENCLATURAS

Clone -> Quando um novo objeto com igual conteúdo é criado.
Copy -> Quando apenas o conteúdo é copiado entre dois objetos já existentes.
Input/Output -> Quando apenas o conteúdo é copiados com "parâmetros não-garantidos" pelo Qwadro. A exemplo, passando 'offset' e/ou 'range' especificados pelo invocador.
Fetch -> Quando há 'destreza' em uma função para conseguir algo. A exemplo, carregando um arquivo implicitamente.
Deploy -> Quando um objeto não-referenciável é empregado, isto é, inicializado, mas não é alocado.
Drop -> Quando um objeto não-referenciável é retirado, isto é, zerado, mas não é desalocado.

Funções Enumerate() deveriam contar quantas instâncias há caso um receptáculo não seja passado adentro.

// TODO

Carregar arquivos ZIP como diretórios virtuais.
Carregar objetos por JSON.

