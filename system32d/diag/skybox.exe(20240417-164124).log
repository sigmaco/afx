Booting up the Qwadro Execution Ecosystem...
Setting up SystemSetting up String BaseafxManifest.c:327
1: Section 'BasedOn="E:\qwadro\afx"' missing ']' operator.Setting up ThreadSetting up Memory Management UnitSetting up ServiceSetting up CodecSetting up StreamSetting up ArchiveSetting up StorageSetting up ModuleSetting up DeviceAcquiring thread...  5404 "afxSystem_w32.c:484"Mounting storage unit... <.>('E:/qwadro/afx///'),5Mounting storage unit... <system>('E:/qwadro/afx//system/'),5Mounting storage unit... <system>('E:/qwadro/afx//system32/'),7Mounting storage unit... <system>('E:/qwadro/afx//system32d/'),7Loading module... <system/e2coree.dll>Memory page size: 4096Logical processor count: 2Doing the AVX start up...Loading module... <e2draw>afxStorage.c:153
afxStorage.c:215
Setting up DrawSystemSetting up CameraSetting up DrawDevice[Device]Setting up DrawOutputSetting up DrawInputLoading module... <targl4.dll>Installable client driver discovered.
	Device: TARGA Advanced Raster Graphics Adapter
	Driver: TARGA over OpenGL 4
	Version: 4.0.16385
	Provider: SIGMA Technology Group <https://sigmaco.org>
Setting up DrawBridgeSetting up DrawContextLoading module... <opengl32.dll>afxStorage.c:153
afxStorage.c:215
Listing mem available display devices...
#0 = Intel(R) HD Graphics (\\.\DISPLAY1) 8080005#1 = RDPDD Chained DD (\\.\DISPLAYV1) 200008#2 = RDP Encoder Mirror Driver (\\.\DISPLAYV2) 200008#3 = RDP Reflector Display Driver (\\.\DISPLAYV3) 200008Acquiring thread...  0 "sglDdev_w32.c:1076"afxThread_w32.c:558
afxThread_w32.c:558
(thr->osHandle)
    InvalidDoing the ASX start up...Loading module... <e2sound>afxStorage.c:153
afxStorage.c:215
Starting Thread Execution Unit 4936Setting up SoundSystemSetting up SoundDevice[Device]Setting up SoundOutputSetting up SoundInputLoading module... <oal4d.dll>Installable client driver discovered.
	Device: A4D Sound Acceleration Adapter
	Driver: A4D over OpenAL 1
	Version: 0.1.1514
	Provider: SIGMA Technology Group <https://sigmaco.org>
Setting up SoundBrigeSetting up SoundContextLoading module... <openal32.dll>Acquiring thread...  0 "salSdev_w32.c:448"The audience is listeningDoing the AUX start up...Loading module... <e2ux>afxStorage.c:153
afxStorage.c:215
Setting up ShellSetting up HIDSetting up Controller[HID]Setting up WindowSetting up ScriptStarting Thread Execution Unit 6760Acquiring HID at port 0Mounting storage unit... <code>('E:/qwadro/afx//system/'),7Loading file... <system/qwadro.xss>('E:/qwadro/afx//system//qwadro.xss')// This technology is part of Qwadro (c) 2017 SIGMA Federation
require "core" for Storage, Stream

class Main {
  construct new() {
    System.print("new");
  }

  init() {
    System.print("init");
    //Storage.Mount("tmp", "system/tmp", "rwx");
    var f = Stream.OpenFile("tmp/camera.lua", "rwx");
    f.Seek(10, 0);
    f.Write("stdout", 6, 0);
    f.Close();
  }

  update() {
    System.print("update");
  }

  draw(dt) {
    System.print("draw");
  }
  

}

Storage.Mount("code", "code", "rx");
Storage.Mount("sound", "sound", "rx");
Storage.Mount("data", "data", "rx");
Storage.Mount("art", "art", "rx");
Storage.Mount("tmp", "tmp", "rwx");

var Game = Main.new();
System.print(".");
var file = Stream.OpenFile("tmp/camera.lua", "rwx");
file.Seek(1, 0);
file.Close();

Loading file... <code/core.xs>('E:/qwadro/afx//system//core.xs')Mounting storage unit... <code>('E:/qwadro/afx//code/'),5Mounting storage unit... <sound>('E:/qwadro/afx//sound/'),5Mounting storage unit... <data>('E:/qwadro/afx//data/'),5Mounting storage unit... <art>('E:/qwadro/afx//art/'),5Mounting storage unit... <tmp>('E:/qwadro/afx//tmp/'),7new
.
Opening file... <tmp/camera.lua>('E:/qwadro/afx//tmp//camera.lua'),7Entering the Thread Execution Environment 5404
Setting up CmdBufferSetting up CmdBufferSetting up CmdBufferSetting up CmdBufferSetting up CmdBufferSetting up CmdBufferSetting up SemaphoreSetting up FenceSetting up Query PoolSetting up LigatureSetting up SamplerSetting up BufferSetting up RasterSetting up CanvasSetting up Vertex InputSetting up ShaderSetting up RasterizerSetting up PipelineUploading pipeline 'system/video/sampleOutRgba.xsh.xml'Loading file... <system/video/sampleOutRgba.xsh.xml>('E:/qwadro/afx//system//video/sampleOutRgba.xsh.xml')system/video/uvOutTristripQuad.vshsystem/video/sampleOutRgba.xsh.xmlUploading pipeline 'system/video/sampleOutRgba.xsh.xml'Loading file... <system/video/sampleOutRgba.xsh.xml>('E:/qwadro/afx//system//video/sampleOutRgba.xsh.xml')Node 'DepthWriteEnabled' not handled.system/video/sampleOutRgba2d.fshOpening file... <system/video/sampleOutRgba2d.fsh>('E:/qwadro/afx//system//video/sampleOutRgba2d.fsh'),1Opening file... <system/video/stdEnv.inc>('E:/qwadro/afx//system//video/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

SAMPLING_UNIT(0, 0, sampler2D, samp);

in block
{
    vec2 uv0;
} sgl_v;

OUT(0, vec4, sgl_rgba);

void main()
{
    sgl_rgba = texture(samp, sgl_v.uv0);
}
Opening file... <system/video/uvOutTristripQuad.vsh>('E:/qwadro/afx//system//video/uvOutTristripQuad.vsh'),1Opening file... <system/video/stdEnv.inc>('E:/qwadro/afx//system//video/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

const vec4 gsQuadPos[4] = vec4[](vec4(-1, 1, 0, 1), vec4(-1,-1, 0, 1), vec4(1, 1, 0, 1), vec4(1,-1, 0, 1));
const vec2 gsQuadUv[4] = vec2[](vec2(0, 1), vec2(0, 0), vec2(1, 1), vec2(1, 0));

out block
{
    vec2 uv0;
} sgl_v;

void main()
{
    // draw a full coverage quad based on two tristripped triangles (4 indices). AfxDraw(0, 1, 0, 4)
    
    gl_Position = gsQuadPos[gl_VertexID];
    sgl_v.uv0 = gsQuadUv[gl_VertexID];
}
Reloading file 0... <system/video/font-256.tga>('E:/qwadro/afx//system//video/font-256.tga')Entering the Thread Execution Environment 4936
Creating transient OpenGL context000 wglMakeContextCurrentARB core found.000 wglGetCurrentReadDCARB core found.000 wglCreateContextAttribsARB core found.000 wglChoosePixelFormatARB core found.000 wglSwapIntervalEXT core found.000 wglGetExtensionsStringARB core found.Creating definitive OpenGL context000 wglMakeContextCurrentARB core found.000 wglGetCurrentReadDCARB core found.000 wglCreateContextAttribsARB core found.000 wglChoosePixelFormatARB core found.000 wglSwapIntervalEXT core found.000 wglGetExtensionsStringARB core found.391 glReleaseShaderCompiler core found.392 glShaderBinary core found.393 glGetShaderPrecisionFormat core found.394 glDepthRangef core found.395 glClearDepthf core found.396 glGetProgramBinary core found.397 glProgramBinary core found.398 glProgramParameteri core found.399 glUseProgramStages core found.400 glActiveShaderProgram core found.401 glCreateShaderProgramv core found.402 glBindProgramPipeline core found.403 glDeleteProgramPipelines core found.404 glGenProgramPipelines core found.405 glIsProgramPipeline core found.406 glGetProgramPipelineiv core found.407 glProgramUniform1i core found.408 glProgramUniform1iv core found.409 glProgramUniform1f core found.410 glProgramUniform1fv core found.411 glProgramUniform1d core found.412 glProgramUniform1dv core found.413 glProgramUniform1ui core found.414 glProgramUniform1uiv core found.415 glProgramUniform2i core found.416 glProgramUniform2iv core found.417 glProgramUniform2f core found.418 glProgramUniform2fv core found.419 glProgramUniform2d core found.420 glProgramUniform2dv core found.421 glProgramUniform2ui core found.422 glProgramUniform2uiv core found.423 glProgramUniform3i core found.424 glProgramUniform3iv core found.425 glProgramUniform3f core found.426 glProgramUniform3fv core found.427 glProgramUniform3d core found.428 glProgramUniform3dv core found.429 glProgramUniform3ui core found.430 glProgramUniform3uiv core found.431 glProgramUniform4i core found.432 glProgramUniform4iv core found.433 glProgramUniform4f core found.434 glProgramUniform4fv core found.435 glProgramUniform4d core found.436 glProgramUniform4dv core found.437 glProgramUniform4ui core found.438 glProgramUniform4uiv core found.439 glProgramUniformMatrix2fv core found.440 glProgramUniformMatrix3fv core found.441 glProgramUniformMatrix4fv core found.442 glProgramUniformMatrix2dv core found.443 glProgramUniformMatrix3dv core found.444 glProgramUniformMatrix4dv core found.445 glProgramUniformMatrix2x3fv core found.446 glProgramUniformMatrix3x2fv core found.447 glProgramUniformMatrix2x4fv core found.448 glProgramUniformMatrix4x2fv core found.449 glProgramUniformMatrix3x4fv core found.450 glProgramUniformMatrix4x3fv core found.451 glProgramUniformMatrix2x3dv core found.452 glProgramUniformMatrix3x2dv core found.453 glProgramUniformMatrix2x4dv core found.454 glProgramUniformMatrix4x2dv core found.455 glProgramUniformMatrix3x4dv core found.456 glProgramUniformMatrix4x3dv core found.457 glValidateProgramPipeline core found.458 glGetProgramPipelineInfoLog core found.459 glVertexAttribL1d core found.460 glVertexAttribL2d core found.461 glVertexAttribL3d core found.462 glVertexAttribL4d core found.463 glVertexAttribL1dv core found.464 glVertexAttribL2dv core found.465 glVertexAttribL3dv core found.466 glVertexAttribL4dv core found.467 glVertexAttribLPointer core found.468 glGetVertexAttribLdv core found.469 glViewportArrayv core found.470 glViewportIndexedf core found.471 glViewportIndexedfv core found.472 glScissorArrayv core found.473 glScissorIndexed core found.474 glScissorIndexedv core found.475 glDepthRangeArrayv core found.476 glDepthRangeIndexed core found.477 glGetFloati_v core found.478 glGetDoublei_v core found.479 glDrawArraysInstancedBaseInstance core found.480 glDrawElementsInstancedBaseInstance core found.481 glDrawElementsInstancedBaseVertexBaseInstance core found.482 glGetInternalformativ core found.483 glGetActiveAtomicCounterBufferiv core found.484 glBindImageTexture core found.485 glMemoryBarrier core found.486 glTexStorage1D core found.487 glTexStorage2D core found.488 glTexStorage3D core found.489 glDrawTransformFeedbackInstanced core found.490 glDrawTransformFeedbackStreamInstanced core found.493 glDispatchCompute core found.494 glDispatchComputeIndirect core found.Entering the Thread Execution Environment 5404
afxRaster.c:174
afxRaster.c:174
<layerIdx>1 + <1>1 is out of capacity <ras->whd[2]>1.Entering the Thread Execution Environment 4936
496 glFramebufferParameteri core found.497 glGetFramebufferParameteriv core found.498 glGetInternalformati64v core found.503 glInvalidateFramebuffer core found.504 glInvalidateSubFramebuffer core found.505 glMultiDrawArraysIndirect core found.506 glMultiDrawElementsIndirect core found.507 glGetProgramInterfaceiv core found.508 glGetProgramResourceIndex core found.509 glGetProgramResourceName core found.510 glGetProgramResourceiv core found.511 glGetProgramResourceLocation core found.512 glGetProgramResourceLocationIndex core found.513 glShaderStorageBlockBinding core found.514 glTexBufferRange core found.515 glTexStorage2DMultisample core found.516 glTexStorage3DMultisample core found.518 glBindVertexBuffer core found.519 glVertexAttribFormat core found.520 glVertexAttribIFormat core found.521 glVertexAttribLFormat core found.522 glVertexAttribBinding core found.523 glVertexBindingDivisor core found.524 glDebugMessageControl core found.525 glDebugMessageInsert core found.526 glDebugMessageCallback core found.527 glGetDebugMessageLog core found.528 glPushDebugGroup core found.529 glPopDebugGroup core found.530 glObjectLabel core found.531 glGetObjectLabel core found.532 glObjectPtrLabel core found.533 glGetObjectPtrLabel core found.534 glBufferStorage core found.543 glClipControlEXT ext found.551 glNamedBufferStorageEXT ext found.589 glTextureBufferRangeEXT ext found.606 glTextureParameteriEXT ext found.641 glMemoryBarrierByRegion core found.644 glGetGraphicsResetStatusARB ext found.645 glGetnCompressedTexImageARB ext found.646 glGetnTexImageARB ext found.647 glGetnUniformdvARB ext found.648 glGetnUniformfvARB ext found.649 glGetnUniformivARB ext found.650 glGetnUniformuivARB ext found.651 glReadnPixelsARB ext found.677 381 1920 1080 96 96 32 1 36 36 51 60 1 SIGMA GL/2 Hardware-accelerated Draw Processing Unit 000
	Intel(R) HD Graphics 4.0.0 - Build 10.18.10.5161sglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglDdev_w32.c:744
GL: INVAL_PARAMsglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglDdev_w32.c:770
GL: INVAL_PARAMsglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglDdev_w32.c:780
GL: INVAL_PARAMsglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglDdev_w32.c:782
GL: INVAL_PARAMsglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglDdev_w32.c:786
GL: INVAL_PARAMafxRaster 0311e1a0 hardware-side data instanced. Target de1, format 8058, whd [4096,4096,1]Entering the Thread Execution Environment 5404
Uploading pipeline 'system/video/font.xsh.xml?instanced'Loading file... <system/video/font.xsh.xml>('E:/qwadro/afx//system//video/font.xsh.xml')system/video/font.vshsystem/video/font.xsh.xml?instancedUploading pipeline 'system/video/font.xsh.xml?instanced'Loading file... <system/video/font.xsh.xml>('E:/qwadro/afx//system//video/font.xsh.xml')Node 'DepthWriteEnabled' not handled.system/video/font.fshOpening file... <system/video/font.fsh>('E:/qwadro/afx//system//video/font.fsh'),1Opening file... <system/video/stdEnv.inc>('E:/qwadro/afx//system//video/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

SAMPLING_UNIT(0, 1, sampler2D, atlas);

in block
{
    vec2 uv;
    vec4 rgba;
} sgl_v;

OUT(0, vec4, sgl_rgba);

void main()
{    
    vec4 sampled = texture(atlas, sgl_v.uv); //vec4(1.0, 1.0, 1.0, texture(samp, sgl_v.uv0).a);
    sgl_rgba = sgl_v.rgba * sampled;
    //sgl_rgba = vec4(/*sgl_v.rgba.rgb*/vec3(1.0, 1.0, 1.0), texture(atlas, sgl_v.uv).r);
}
Opening file... <system/video/font.vsh>('E:/qwadro/afx//system//video/font.vsh'),1Opening file... <system/video/stdEnv.inc>('E:/qwadro/afx//system//video/stdEnv.inc'),1Opening file... <system/video/stdView.inc>('E:/qwadro/afx//system//video/stdView.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, sgl_view)
{
    mat4 v;
    mat4 iv;
    mat4 p;
    mat4 ip;
    mat4 vp;
    mat4 ivp;
    
    vec4 viewPos; // view point
    vec2 viewExtent;

    vec3 starDir;
    vec4 starPos;
    vec4 starKd;
};

IN(0, vec2, in_instPos);
IN(1, vec2, in_instUv);
IN(2, vec4, in_instRgba);

const vec2 pos[4] =
{
    vec2( 0, 16),
    vec2( 0, 0),
    vec2(16, 16),
    vec2(16, 0)
};
const vec2 uv[4] =
{
    vec2(0.00625, -0.00625),
    vec2(0.00625, -0.05625),
    vec2(0.05625, -0.00625),
    vec2(0.05652, -0.05625)
};

out block
{
    vec2 uv;
    vec4 rgba;
} sgl_v;

void main()
{
    gl_Position = p * vec4((pos[gl_VertexID] + in_instPos), 0.0, 1.0);
    sgl_v.uv = uv[gl_VertexID] + in_instUv;
    sgl_v.rgba = vec4(1,1,1,1);//in_instRgba;
}
Setting up WidgetafxDrawOutput 000 readapted. 1920x1080 @ 60.000000Hz <1.777778r, 1.776903p>afxDrawOutput 000 adjusted. <952, 1920, 0.496> 1.881423 <506, 1080, 0.469>Setting up SimulationSetting up MaterialSetting up Mesh TopologySetting up Vertex DataSetting up MeshSetting up SkeletonSetting up ModelSetting up MotionSetting up AnimationSetting up MotorSetting up BodySetting up EntitySetting up LightSetting up CAD AssetSetting up RendererSetting up Vertex BufferEntering the Thread Execution Environment 4936
sglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglBuf.c:164
GL: INVAL_PARAMsglBuf.c:165
sglBuf.c:165
(gl->IsBuffer(glHandle))
    InvalidsglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglBuf.c:172
GL: INVAL_PARAMafxBuffer 0063a3c0 hardware-side data instanced. glTarget 0, glHandle 1, offset 0, range 48, stride 0, usage 500sglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglBuf.c:178
GL: INVAL_PARAMsglDdev_w32.c:299
API ERROR HIGH 1281 GL error GL_INVALID_VALUEsglBuf.c:244
GL: INVAL_VALUEafxBuffer 0063a3c0 hardware-side data instanced. glTarget 34962, glHandle 2, offset 0, range 48, stride 0, usage 500sglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglBuf.c:164
GL: INVAL_PARAMsglBuf.c:165
sglBuf.c:165
(gl->IsBuffer(glHandle))
    InvalidsglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglBuf.c:172
GL: INVAL_PARAMafxBuffer 0063a438 hardware-side data instanced. glTarget 0, glHandle 3, offset 0, range 24, stride 0, usage 500sglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglBuf.c:178
GL: INVAL_PARAMsglDdev_w32.c:299
API ERROR HIGH 1281 GL error GL_INVALID_VALUEsglBuf.c:244
GL: INVAL_VALUEafxBuffer 0063a438 hardware-side data instanced. glTarget 34963, glHandle 4, offset 0, range 24, stride 0, usage 500Entering the Thread Execution Environment 5404
Uploading pipeline 'data/pipeline/test/test.xsh.xml'Loading file... <data/pipeline/test/test.xsh.xml>('E:/qwadro/afx//data//pipeline/test/test.xsh.xml')data/pipeline/test/test.vshdata/pipeline/test/test.xsh.xmlUploading pipeline 'data/pipeline/test/test.xsh.xml'Loading file... <data/pipeline/test/test.xsh.xml>('E:/qwadro/afx//data//pipeline/test/test.xsh.xml')Node 'DepthWriteEnabled' not handled.data/pipeline/test/test.fshOpening file... <data/pipeline/test/test.fsh>('E:/qwadro/afx//data//pipeline/test/test.fsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

OUT(0, vec4, sgl_rgba);

void main()
{
    sgl_rgba = vec4(0.5, 0.5, 0.5, 1.0);
}
Opening file... <data/pipeline/test/test.vsh>('E:/qwadro/afx//data//pipeline/test/test.vsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1Opening file... <data/pipeline/stdView.inc>('E:/qwadro/afx//data//pipeline/stdView.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, sgl_view)
{
    mat4 v;
    mat4 iv;
    mat4 p;
    mat4 ip;
    mat4 vp;
    mat4 ivp;
    
    vec4 viewPos; // view point
    vec2 viewExtent;

    vec3 starDir;
    vec4 starPos;
    vec4 starKd;
};

IN(0, vec3, a_xyz);

void main()
{
    vec4 pos = p * v * vec4(a_xyz, 1.0);
    gl_Position = pos;
}
Reloading file 0... <art/skybox/purple/right.tga>('E:/qwadro/afx//art//skybox/purple/right.tga')Entering the Thread Execution Environment 6760
0  - OpenAL Soft1  - Generic SoftwareListing devices available with ALC_ENUMERATE_ALL_EXT0  - OpenAL Soft on Alto-falantes (VIA HD Audio(Compatible))1  - OpenAL Soft on Headphone (VIA HD Audio(Compatible))2  - Generic Software on Alto-falantes (VIA HD Audio(Compatible))3  - Generic Software on Headphone (VIA HD Audio(Compatible))Listing available capture devices:0  - OpenAL Soft on Mixagem estÃ©reo (VIA HD Audio(Compatible))1  - OpenAL Soft on Microfone (VIA HD Audio(Compatible))2  - Mixagem estéreo (VIA HD Audio(C3  - Microfone (VIA HD Audio(CompatiOpening file... <system/qwadroDeepNote>('E:/qwadro/afx//system//qwadroDeepNote'),1Entering the Thread Execution Environment 4936
afxRaster 082d0a40 hardware-side data instanced. Target 8513, format 8051, whd [2048,2048,6]Entering the Thread Execution Environment 5404
Reloading file 0... <art/skybox/purple/left.tga>('E:/qwadro/afx//art//skybox/purple/left.tga')Reloading file 0... <art/skybox/purple/bottom.tga>('E:/qwadro/afx//art//skybox/purple/bottom.tga')Reloading file 0... <art/skybox/purple/top.tga>('E:/qwadro/afx//art//skybox/purple/top.tga')Reloading file 0... <art/skybox/purple/front.tga>('E:/qwadro/afx//art//skybox/purple/front.tga')Reloading file 0... <art/skybox/purple/back.tga>('E:/qwadro/afx//art//skybox/purple/back.tga')Entering the Thread Execution Environment 4936
sglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglBuf.c:164
GL: INVAL_PARAMsglBuf.c:165
sglBuf.c:165
(gl->IsBuffer(glHandle))
    InvalidsglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglBuf.c:172
GL: INVAL_PARAMafxBuffer 0063a4f0 hardware-side data instanced. glTarget 0, glHandle 5, offset 0, range 432, stride 0, usage 500sglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglBuf.c:178
GL: INVAL_PARAMsglDdev_w32.c:299
API ERROR HIGH 1281 GL error GL_INVALID_VALUEsglBuf.c:244
GL: INVAL_VALUEafxBuffer 0063a4f0 hardware-side data instanced. glTarget 34962, glHandle 6, offset 0, range 432, stride 0, usage 500Entering the Thread Execution Environment 5404
Uploading pipeline 'data/pipeline/skybox/skybox.xsh.xml'Loading file... <data/pipeline/skybox/skybox.xsh.xml>('E:/qwadro/afx//data//pipeline/skybox/skybox.xsh.xml')data/pipeline/skybox/skybox.vshdata/pipeline/skybox/skybox.xsh.xmlUploading pipeline 'data/pipeline/skybox/skybox.xsh.xml'Loading file... <data/pipeline/skybox/skybox.xsh.xml>('E:/qwadro/afx//data//pipeline/skybox/skybox.xsh.xml')Node 'DepthWriteEnabled' not handled.data/pipeline/skybox/sampleOutRgbaCube.fshOpening file... <data/pipeline/skybox/sampleOutRgbaCube.fsh>('E:/qwadro/afx//data//pipeline/skybox/sampleOutRgbaCube.fsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

SAMPLING_UNIT(0, 1, samplerCube, samp);

in block
{
    vec3 uvw0;
} sgl_v;

OUT(0, vec4, sgl_rgba);

void main()
{
    sgl_rgba = texture(samp, sgl_v.uvw0);
}
Opening file... <data/pipeline/skybox/skybox.vsh>('E:/qwadro/afx//data//pipeline/skybox/skybox.vsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1Opening file... <data/pipeline/stdView.inc>('E:/qwadro/afx//data//pipeline/stdView.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, sgl_view)
{
    mat4 v;
    mat4 iv;
    mat4 p;
    mat4 ip;
    mat4 vp;
    mat4 ivp;
    
    vec4 viewPos; // view point
    vec2 viewExtent;

    vec3 starDir;
    vec4 starPos;
    vec4 starKd;
};

IN(0, vec3, a_xyz);

const vec3 points[] =
{
    {-1.0, 1.0,-1.0 },
    {-1.0,-1.0,-1.0 },
    { 1.0,-1.0,-1.0 },
    { 1.0,-1.0,-1.0 },
    { 1.0, 1.0,-1.0 },
    {-1.0, 1.0,-1.0 },

    {-1.0,-1.0, 1.0 },
    {-1.0,-1.0,-1.0 },
    {-1.0, 1.0,-1.0 },
    {-1.0, 1.0,-1.0 },
    {-1.0, 1.0, 1.0 },
    {-1.0,-1.0, 1.0 },

    { 1.0,-1.0,-1.0 },
    { 1.0,-1.0, 1.0 },
    { 1.0, 1.0, 1.0 },
    { 1.0, 1.0, 1.0 },
    { 1.0, 1.0,-1.0 },
    { 1.0,-1.0,-1.0 },

    {-1.0,-1.0, 1.0 },
    {-1.0, 1.0, 1.0 },
    { 1.0, 1.0, 1.0 },
    { 1.0, 1.0, 1.0 },
    { 1.0,-1.0, 1.0 },
    {-1.0,-1.0, 1.0 },

    {-1.0, 1.0,-1.0 },
    { 1.0, 1.0,-1.0 },
    { 1.0, 1.0, 1.0 },
    { 1.0, 1.0, 1.0 },
    {-1.0, 1.0, 1.0 },
    {-1.0, 1.0,-1.0 },

    {-1.0,-1.0,-1.0 },
    {-1.0,-1.0, 1.0 },
    { 1.0,-1.0,-1.0 },
    { 1.0,-1.0,-1.0 },
    {-1.0,-1.0, 1.0 },
    { 1.0,-1.0, 1.0 }
};

out block
{
    vec3 uvw0;
} sgl_v;

void main()
{
    vec3 xyz = points[gl_VertexID];
    sgl_v.uvw0 = xyz;
    
    // Convert cubemap coordinates into Vulkan coordinate space
    sgl_v.uvw0.xy *= -1.0;
    
    // Remove translation from view matrix
    vec4 pos = p * mat4(mat3(v)) * vec4(xyz, 1.0);
    
    gl_Position = pos.xyww;
}
Uploading pipeline 'data/pipeline/body/body.xsh.xml?rigid'Loading file... <data/pipeline/body/body.xsh.xml>('E:/qwadro/afx//data//pipeline/body/body.xsh.xml')data/pipeline/body/rigidBody.vshdata/pipeline/body/body.xsh.xmlUploading pipeline 'data/pipeline/body/body.xsh.xml'Loading file... <data/pipeline/body/body.xsh.xml>('E:/qwadro/afx//data//pipeline/body/body.xsh.xml')Node 'DepthWriteEnabled' not handled.data/pipeline/body/body.fshOpening file... <data/pipeline/body/body.fsh>('E:/qwadro/afx//data//pipeline/body/body.fsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1Opening file... <data/pipeline/stdView.inc>('E:/qwadro/afx//data//pipeline/stdView.inc'),1Opening file... <data/pipeline/stdMaterial.inc>('E:/qwadro/afx//data//pipeline/stdMaterial.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, sgl_view)
{
    mat4 v;
    mat4 iv;
    mat4 p;
    mat4 ip;
    mat4 vp;
    mat4 ivp;
    
    vec4 viewPos; // view point
    vec2 viewExtent;

    vec3 starDir;
    vec4 starPos;
    vec4 starKd;
};

UNIFORM_UNIT(2, 0, sgl_mtl)
{
    vec3  Kd;
    vec3  Ks;
    float Ns;
    float d;
    float Ni;
    int   illum;
};

UNIFORM(0, 0, sampler2D, diffuse_sampler);
        
in block
{
    vec3 xyz;
    vec3 nrm;
    vec2 uv0;
} sgl_v;

OUT(0, vec4, FragColor);

const vec3 lightPosition = vec3(10, 10, 10);
const vec3 lightAmbient = vec3(0.1, 0.1, 0.1);
const vec3 lightDiffuse = vec3(0.5, 0.5, 0.5);
const vec3 lightSpecular = vec3(0.5, 0.5, 0.5);

void main()
{
    // ambient
    vec3 ambient = lightAmbient;
    
    // diffuse 
    vec3 norm = normalize(sgl_v.nrm);
    vec3 lightDir = normalize(lightPosition - sgl_v.xyz);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = lightDiffuse * (diff * Kd);
    
    // specular
    vec3 viewDir = normalize(vec3(viewpoint.xyz) - sgl_v.xyz);
    vec3 reflectDir = reflect(-lightDir, norm);  
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), Ns);
    vec3 specular = lightSpecular * (spec * Ks);  
        
    vec3 result = ambient + diffuse + specular;
    FragColor = vec4(result, 1.0);
}
Opening file... <data/pipeline/body/rigidBody.vsh>('E:/qwadro/afx//data//pipeline/body/rigidBody.vsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1Opening file... <data/pipeline/stdView.inc>('E:/qwadro/afx//data//pipeline/stdView.inc'),1Opening file... <data/pipeline/stdObject.inc>('E:/qwadro/afx//data//pipeline/stdObject.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, sgl_view)
{
    mat4 v;
    mat4 iv;
    mat4 p;
    mat4 ip;
    mat4 vp;
    mat4 ivp;
    
    vec4 viewPos; // view point
    vec2 viewExtent;

    vec3 starDir;
    vec4 starPos;
    vec4 starKd;
};

UNIFORM_UNIT(3, 0, sgl_obj)
{
    mat4 m;
    mat4 w[32];
};

IN(0, vec3, aPos);
IN(3, vec3, aNormal);
IN(6, vec2, aUv);

const vec4 AmbientColour = vec4(0.2, 0.2, 0.2, 1.0);

out block
{
    vec3 xyz;
    vec3 nrm;
    vec2 uv0;
} sgl_v;

void main()
{
    sgl_v.xyz = vec3(m * vec4(aPos, 1));
    sgl_v.nrm = mat3(transpose(inverse(m))) * aNormal;  
    
    gl_Position = p * v * vec4(sgl_v.xyz, 1.0);
}
Uploading pipeline 'data/pipeline/body/body.xsh.xml?skinned'Loading file... <data/pipeline/body/body.xsh.xml>('E:/qwadro/afx//data//pipeline/body/body.xsh.xml')data/pipeline/body/skinnedBody.vshdata/pipeline/body/body.xsh.xmlUploading pipeline 'data/pipeline/body/body.xsh.xml'Loading file... <data/pipeline/body/body.xsh.xml>('E:/qwadro/afx//data//pipeline/body/body.xsh.xml')Node 'DepthWriteEnabled' not handled.data/pipeline/body/body.fshOpening file... <data/pipeline/body/body.fsh>('E:/qwadro/afx//data//pipeline/body/body.fsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1Opening file... <data/pipeline/stdView.inc>('E:/qwadro/afx//data//pipeline/stdView.inc'),1Opening file... <data/pipeline/stdMaterial.inc>('E:/qwadro/afx//data//pipeline/stdMaterial.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, sgl_view)
{
    mat4 v;
    mat4 iv;
    mat4 p;
    mat4 ip;
    mat4 vp;
    mat4 ivp;
    
    vec4 viewPos; // view point
    vec2 viewExtent;

    vec3 starDir;
    vec4 starPos;
    vec4 starKd;
};

UNIFORM_UNIT(2, 0, sgl_mtl)
{
    vec3  Kd;
    vec3  Ks;
    float Ns;
    float d;
    float Ni;
    int   illum;
};

UNIFORM(0, 0, sampler2D, diffuse_sampler);
        
in block
{
    vec3 xyz;
    vec3 nrm;
    vec2 uv0;
} sgl_v;

OUT(0, vec4, FragColor);

const vec3 lightPosition = vec3(10, 10, 10);
const vec3 lightAmbient = vec3(0.1, 0.1, 0.1);
const vec3 lightDiffuse = vec3(0.5, 0.5, 0.5);
const vec3 lightSpecular = vec3(0.5, 0.5, 0.5);

void main()
{
    // ambient
    vec3 ambient = lightAmbient;
    
    // diffuse 
    vec3 norm = normalize(sgl_v.nrm);
    vec3 lightDir = normalize(lightPosition - sgl_v.xyz);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = lightDiffuse * (diff * Kd);
    
    // specular
    vec3 viewDir = normalize(vec3(viewpoint.xyz) - sgl_v.xyz);
    vec3 reflectDir = reflect(-lightDir, norm);  
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), Ns);
    vec3 specular = lightSpecular * (spec * Ks);  
        
    vec3 result = ambient + diffuse + specular;
    FragColor = vec4(result, 1.0);
}
Opening file... <data/pipeline/body/skinnedBody.vsh>('E:/qwadro/afx//data//pipeline/body/skinnedBody.vsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1Opening file... <data/pipeline/stdView.inc>('E:/qwadro/afx//data//pipeline/stdView.inc'),1Opening file... <data/pipeline/stdObject.inc>('E:/qwadro/afx//data//pipeline/stdObject.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, sgl_view)
{
    mat4 v;
    mat4 iv;
    mat4 p;
    mat4 ip;
    mat4 vp;
    mat4 ivp;
    
    vec4 viewPos; // view point
    vec2 viewExtent;

    vec3 starDir;
    vec4 starPos;
    vec4 starKd;
};

UNIFORM_UNIT(3, 0, sgl_obj)
{
    mat4 m;
    mat4 w[32];
};

IN(0, vec3, aPos);
IN(1, vec4, aBlendIndices);
IN(2, vec4, aBlendWeights);
IN(3, vec3, aNormal);
IN(6, vec2, aUv);

out block
{
    vec3 Position;
    vec4 Diffuse;
    vec2 Tex0;
} sgl_v;

const vec4 AmbientColour = vec4(0.2, 0.2, 0.2, 1.0);

void main()
{
    vec3 InPos     = aPos;
    vec4 WorldPos    = 0;
    vec3 WorldNormal = 0;
    
    // We're going to assume that we can transform the normal by the matrix, which is not
    // technically correct unless we're positive there's not a scaling factor involved.

    for( int i = 0; i < 4; ++i )
    {
        mat4 BoneMatrix = w[int(aBlendIndices[i])];
        WorldPos    += (aBlendWeights[i] * (BoneMatrix * vec4(InPos, 1)));
        WorldNormal += vec3(vec4(aBlendWeights[i] * (BoneMatrix * vec4(aNormal, 0))));
    }

    vec4 ViewPosL = (WorldPos * v);
    vec4 ClipPos = (ViewPosL * p);
    gl_Position = ClipPos;
    sgl_v.Position   = vec3(ClipPos);
    sgl_v.Tex0    = aUv;
    sgl_v.Diffuse = starKd * (dot(normalize(WorldNormal), starDir)) + AmbientColour;
}
Uploading pipeline 'data/pipeline/testLighting/testLighting.xsh.xml?blinn'Loading file... <data/pipeline/testLighting/testLighting.xsh.xml>('E:/qwadro/afx//data//pipeline/testLighting/testLighting.xsh.xml')data/pipeline/testLighting/testLightingBlinn.vshdata/pipeline/testLighting/testLighting.xsh.xmlUploading pipeline 'data/pipeline/testLighting/testLighting.xsh.xml'Loading file... <data/pipeline/testLighting/testLighting.xsh.xml>('E:/qwadro/afx//data//pipeline/testLighting/testLighting.xsh.xml')Node 'DepthWriteEnabled' not handled.data/pipeline/testLighting/testLightingBlinn.fshOpening file... <data/pipeline/testLighting/testLightingBlinn.fsh>('E:/qwadro/afx//data//pipeline/testLighting/testLightingBlinn.fsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1Opening file... <data/pipeline/stdView.inc>('E:/qwadro/afx//data//pipeline/stdView.inc'),1Opening file... <data/pipeline/stdMaterial.inc>('E:/qwadro/afx//data//pipeline/stdMaterial.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, sgl_view)
{
    mat4 v;
    mat4 iv;
    mat4 p;
    mat4 ip;
    mat4 vp;
    mat4 ivp;
    
    vec4 viewPos; // view point
    vec2 viewExtent;

    vec3 starDir;
    vec4 starPos;
    vec4 starKd;
};

UNIFORM_UNIT(2, 0, sgl_mtl)
{
    vec3  Kd;
    vec3  Ks;
    float Ns;
    float d;
    float Ni;
    int   illum;
};

in block
{
    vec4 posn;
    vec3 nrm;
} sgl_in;

OUT(0, vec4, out_rgba0);

vec4 litSrc0Pos = vec4(100, 1000, 0, 1);
vec4 litProd0Ambi = vec4(0.1, 0.1, 0.1, 1);
vec4 litProd0Diff = vec4(0.9, 0.8, 0.7, 1);
vec4 litProd0Spec = vec4(0.1, 0.1, 0.1, 1);
vec4 litModelAmbi = vec4(1, 1, 1, 1);
vec4 mtlAmbi = vec4(0.1, 0.1, 0.1, 1);
float mltShinisses = 10;

void main (void)
{ 
    // calculate light diffusion
    vec3 light = normalize(litSrc0Pos.xyz - sgl_in.posn.xyz); 
    vec3 view = normalize(-sgl_in.posn.xyz); 
    vec3 normal = normalize(sgl_in.nrm); 

    // calculate ambience
    vec4 ambient = litProd0Ambi;
    vec4 global = mtlAmbi * litModelAmbi;

    // get vector to light
    vec4 diffuse = litProd0Diff * max(dot(sgl_in.nrm, light), 0.0);
    diffuse = clamp(diffuse, 0.0, 1.0);

    // Blinn specular variation
    vec3 halfDir = normalize(light + view);
    float spec = pow(max(dot(normal, halfDir), 0.0), mltShinisses * 0.2);
    vec4 specular = litProd0Spec * spec;
    specular = clamp(specular, 0.0, 1.0);

    // do calculations on every fragment
    out_rgba0 = global + ambient + diffuse + specular;
}
Opening file... <data/pipeline/testLighting/testLightingBlinn.vsh>('E:/qwadro/afx//data//pipeline/testLighting/testLightingBlinn.vsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1Opening file... <data/pipeline/stdView.inc>('E:/qwadro/afx//data//pipeline/stdView.inc'),1Opening file... <data/pipeline/stdObject.inc>('E:/qwadro/afx//data//pipeline/stdObject.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, sgl_view)
{
    mat4 v;
    mat4 iv;
    mat4 p;
    mat4 ip;
    mat4 vp;
    mat4 ivp;
    
    vec4 viewPos; // view point
    vec2 viewExtent;

    vec3 starDir;
    vec4 starPos;
    vec4 starKd;
};

UNIFORM_UNIT(3, 0, sgl_obj)
{
    mat4 m;
    mat4 w[32];
};

IN(0, vec3, in_pos);
IN(3, vec3, in_nrm);

out block
{
    vec4 posn;
    vec3 nrm;
} sgl_out;

void main()
{
    sgl_out.posn = v * m * vec4(in_pos, 1);
    mat3 n = mat3(transpose(inverse(m))); // gambiarra
    sgl_out.nrm = normalize(n * in_nrm);

    gl_Position = p * v * m * vec4(in_pos, 1);
}
Uploading pipeline 'data/pipeline/tutCamUtil/tutCamUtil.xsh.xml?tutCamUtil'Loading file... <data/pipeline/tutCamUtil/tutCamUtil.xsh.xml>('E:/qwadro/afx//data//pipeline/tutCamUtil/tutCamUtil.xsh.xml')data/pipeline/tutCamUtil/tutCamUtilRigid.vshdata/pipeline/tutCamUtil/tutCamUtil.xsh.xmlUploading pipeline 'data/pipeline/tutCamUtil/tutCamUtil.xsh.xml'Loading file... <data/pipeline/tutCamUtil/tutCamUtil.xsh.xml>('E:/qwadro/afx//data//pipeline/tutCamUtil/tutCamUtil.xsh.xml')Node 'DepthWriteEnabled' not handled.data/pipeline/tutCamUtil/tutCamUtil.fshOpening file... <data/pipeline/tutCamUtil/tutCamUtil.fsh>('E:/qwadro/afx//data//pipeline/tutCamUtil/tutCamUtil.fsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

in block
{
    vec2 uv0;
    vec3 rgba0;
} sgl_in;

OUT(0, vec4, out_rgba0);

SAMPLING_UNIT(0, 1, sampler2D, diffuse_texture);

void main (void)
{ 
    float3 DiffuseSamp = vec3(1, 1, 1); //texture( diffuse_texture, sgl_in.uv0 );
    DiffuseSamp *= sgl_in.rgba0;

    out_rgba0 = float4(DiffuseSamp, 1);
}
Opening file... <data/pipeline/tutCamUtil/tutCamUtilRigid.vsh>('E:/qwadro/afx//data//pipeline/tutCamUtil/tutCamUtilRigid.vsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1Opening file... <data/pipeline/stdView.inc>('E:/qwadro/afx//data//pipeline/stdView.inc'),1Opening file... <data/pipeline/stdObject.inc>('E:/qwadro/afx//data//pipeline/stdObject.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, sgl_view)
{
    mat4 v;
    mat4 iv;
    mat4 p;
    mat4 ip;
    mat4 vp;
    mat4 ivp;
    
    vec4 viewPos; // view point
    vec2 viewExtent;

    vec3 starDir;
    vec4 starPos;
    vec4 starKd;
};

UNIFORM_UNIT(3, 0, sgl_obj)
{
    mat4 m;
    mat4 w[32];
};

IN(0, vec3, in_pos);
IN(3, vec3, in_nrm);
IN(6, vec2, in_uv0);

out block
{
    vec2 uv0;
    vec3 rgba0;
} sgl_out;

float3 DirFromLight = vec3(100, 100, 0);
float4 LightColour = vec4(0.9, 0.9, 0.9, 1);
float4 AmbientColour = vec4(0.1, 0.1, 0.1, 0.1);

void main()
{
    float4 WorldPos = m * vec4(in_pos, 1);
    float4 ViewPos  = v * WorldPos;
    float4 ClipPos  = p * ViewPos;

    float4 InNormal  = float4( in_nrm, 0);
    float3 ObjNormal = vec4(m * InNormal).xyz;

    sgl_out.uv0     = in_uv0;
    sgl_out.rgba0  = vec3(LightColour * dot(vec4(ObjNormal,0), vec4(DirFromLight,0)) + AmbientColour);

    gl_Position = ClipPos;
}
Uploading pipeline 'data/pipeline/lighting/lighting.xsh.xml?lighting'Loading file... <data/pipeline/lighting/lighting.xsh.xml>('E:/qwadro/afx//data//pipeline/lighting/lighting.xsh.xml')data/pipeline/lighting/lighting.vshdata/pipeline/lighting/lighting.xsh.xmlNode 'Input' not handled.Node 'Input' not handled.Node 'Input' not handled.Uploading pipeline 'data/pipeline/lighting/lighting.xsh.xml'Loading file... <data/pipeline/lighting/lighting.xsh.xml>('E:/qwadro/afx//data//pipeline/lighting/lighting.xsh.xml')Node 'DepthWriteEnabled' not handled.data/pipeline/lighting/lighting.fshOpening file... <data/pipeline/lighting/lighting.fsh>('E:/qwadro/afx//data//pipeline/lighting/lighting.fsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1Opening file... <data/pipeline/stdView.inc>('E:/qwadro/afx//data//pipeline/stdView.inc'),1Opening file... <data/pipeline/stdMaterial.inc>('E:/qwadro/afx//data//pipeline/stdMaterial.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, sgl_view)
{
    mat4 v;
    mat4 iv;
    mat4 p;
    mat4 ip;
    mat4 vp;
    mat4 ivp;
    
    vec4 viewPos; // view point
    vec2 viewExtent;

    vec3 starDir;
    vec4 starPos;
    vec4 starKd;
};

UNIFORM_UNIT(2, 0, sgl_mtl)
{
    vec3  Kd;
    vec3  Ks;
    float Ns;
    float d;
    float Ni;
    int   illum;
};

SAMPLING_UNIT(2, 1, sampler2D, floorTexture);

vec3 lightPos = vec3(100, 100, 0);
int blinn = 1;

in block
{
    vec4 posn;
    vec3 nrm;
    vec2 uv0;
} sgl_in;

OUT(0, vec4, out_rgba0);

void main (void)
{ 
    vec3 color = vec3(0.5,0.5,0.5);//texture(floorTexture, sgl_in.uv0).rgb;
    
    // ambient
    vec3 ambient = 0.05 * color;
    
    // diffuse
    vec3 lightDir = normalize(lightPos - vec3(sgl_in.posn));
    vec3 normal = normalize(sgl_in.nrm);
    float diff = max(dot(lightDir, normal), 0.0);
    vec3 diffuse = diff * color;
    
    // specular
    vec3 viewDir = vec3(normalize(viewPos - sgl_in.posn));
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = 0.0;
    
    if(blinn == 1)
    {
        vec3 halfwayDir = normalize(lightDir + viewDir);  
        spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);
    }
    else
    {
        vec3 reflectDir = reflect(-lightDir, normal);
        spec = pow(max(dot(viewDir, reflectDir), 0.0), 8.0);
    }
    
    vec3 specular = vec3(0.3) * spec; // assuming bright white light color
    out_rgba0 = vec4(ambient + diffuse + specular, 1.0);
}
Opening file... <data/pipeline/lighting/lighting.vsh>('E:/qwadro/afx//data//pipeline/lighting/lighting.vsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1Opening file... <data/pipeline/stdView.inc>('E:/qwadro/afx//data//pipeline/stdView.inc'),1Opening file... <data/pipeline/stdObject.inc>('E:/qwadro/afx//data//pipeline/stdObject.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, sgl_view)
{
    mat4 v;
    mat4 iv;
    mat4 p;
    mat4 ip;
    mat4 vp;
    mat4 ivp;
    
    vec4 viewPos; // view point
    vec2 viewExtent;

    vec3 starDir;
    vec4 starPos;
    vec4 starKd;
};

UNIFORM_UNIT(3, 0, sgl_obj)
{
    mat4 m;
    mat4 w[32];
};

IN(0, vec3, in_pos);
IN(3, vec3, in_nrm);
IN(6, vec2, in_uv0);

out block
{
    vec4 posn;
    vec3 nrm;
    vec2 uv0;
} sgl_out;

void main()
{
    sgl_out.posn = m * vec4(in_pos, 1);
    sgl_out.nrm = in_nrm;
    sgl_out.uv0 = in_uv0;
    gl_Position = p * v * m * vec4(in_pos, 1);
}
Installing watcher <072997d0> for 081ba040...Entering the Thread Execution Environment 4936
afxRaster 0734c7f0 hardware-side data instanced. Target de1, format 8229, whd [512,512,1]afxBuffer 0063a7d8 hardware-side data instanced. glTarget 35345, glHandle 7, offset 0, range 464, stride 0, usage 500sglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglBuf.c:164
GL: INVAL_PARAMsglBuf.c:165
sglBuf.c:165
(gl->IsBuffer(glHandle))
    InvalidsglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglBuf.c:172
GL: INVAL_PARAMafxBuffer 0731bdf8 hardware-side data instanced. glTarget 0, glHandle 8, offset 0, range 2496, stride 0, usage 500sglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglBuf.c:178
GL: INVAL_PARAMsglDdev_w32.c:299
API ERROR HIGH 1281 GL error GL_INVALID_VALUEsglBuf.c:244
GL: INVAL_VALUEafxBuffer 0731bdf8 hardware-side data instanced. glTarget 34962, glHandle 9, offset 0, range 2496, stride 0, usage 500sglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglBuf.c:164
GL: INVAL_PARAMsglBuf.c:165
sglBuf.c:165
(gl->IsBuffer(glHandle))
    InvalidsglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglBuf.c:172
GL: INVAL_PARAMafxBuffer 0731beb0 hardware-side data instanced. glTarget 0, glHandle 10, offset 0, range 960, stride 0, usage 500sglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglBuf.c:178
GL: INVAL_PARAMsglDdev_w32.c:299
API ERROR HIGH 1281 GL error GL_INVALID_VALUEsglBuf.c:244
GL: INVAL_VALUEafxBuffer 0731beb0 hardware-side data instanced. glTarget 35345, glHandle 11, offset 0, range 960, stride 0, usage 500sglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglBuf.c:164
GL: INVAL_PARAMsglBuf.c:165
sglBuf.c:165
(gl->IsBuffer(glHandle))
    InvalidsglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglBuf.c:172
GL: INVAL_PARAMafxBuffer 0731bf28 hardware-side data instanced. glTarget 0, glHandle 12, offset 0, range 8, stride 0, usage 500sglDdev_w32.c:299
API ERROR HIGH 1280 GL error GL_INVALID_ENUMsglBuf.c:178
GL: INVAL_PARAMsglDdev_w32.c:299
API ERROR HIGH 1281 GL error GL_INVALID_VALUEsglBuf.c:244
GL: INVAL_VALUEafxBuffer 0731bf28 hardware-side data instanced. glTarget 35345, glHandle 13, offset 0, range 8, stride 0, usage 500Entering the Thread Execution Environment 5404
Opening file... <system/gui/fill.fsh>('E:/qwadro/afx//system//gui/fill.fsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 1, frag)
{
    mat3 scissorMat;
    mat3 paintMat;
    vec4 innerCol;
    vec4 outerCol;
    vec2 scissorExt;
    vec2 scissorScale;
    vec2 extent;
    float radius;
    float feather;
    float strokeMult;
    float strokeThr;
    int texType;
    int type;
};

SAMPLING_UNIT(0, 2, sampler2D, tex);

in block
{
    vec2 ftcoord;
    vec2 fpos;
} sgl_v;

OUT(0, vec4, outColor);

float sdroundrect(vec2 pt, vec2 ext, float rad) {
	vec2 ext2 = ext - vec2(rad,rad);
	vec2 d = abs(pt) - ext2;
	return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rad;
}

// Scissoring
float scissorMask(vec2 p) {
	vec2 sc = (abs((scissorMat * vec3(p,1.0)).xy) - scissorExt);
	sc = vec2(0.5,0.5) - sc * scissorScale;
	return clamp(sc.x,0.0,1.0) * clamp(sc.y,0.0,1.0);
}
// Stroke - from [0..1] to clipped pyramid, where the slope is 1px.
float strokeMask() {
	return min(1.0, (1.0-abs(sgl_v.ftcoord.x*2.0-1.0))*strokeMult) * min(1.0, sgl_v.ftcoord.y);
}

void mainAA(void) {
   vec4 result;
	float scissor = scissorMask(sgl_v.fpos);
	float strokeAlpha = strokeMask();
	if (strokeAlpha < strokeThr) discard;
	if (type == 0) {			// Gradient
		// Calculate gradient color using box gradient
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy;
		float d = clamp((sdroundrect(pt, extent, radius) + feather*0.5) / feather, 0.0, 1.0);
		vec4 color = mix(innerCol,outerCol,d);
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 1) {		// Image
		// Calculate color fron texture
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy / extent;
		vec4 color = texture(tex, pt);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		// Apply color tint and alpha.
		color *= innerCol;
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 2) {		// Stencil fill
		result = vec4(1,1,1,1);
	} else if (type == 3) {		// Textured tris
		vec4 color = texture(tex, sgl_v.ftcoord);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		color *= scissor;
		result = color * innerCol;
	}
	outColor = result;
}
void main(void) {
   vec4 result;
	float scissor = scissorMask(sgl_v.fpos);
	float strokeAlpha = 1.0;
	if (type == 0) {			// Gradient
		// Calculate gradient color using box gradient
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy;
		float d = clamp((sdroundrect(pt, extent, radius) + feather*0.5) / feather, 0.0, 1.0);
		vec4 color = mix(innerCol,outerCol,d);
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 1) {		// Image
		// Calculate color fron texture
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy / extent;
		vec4 color = texture(tex, pt);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		// Apply color tint and alpha.
		color *= innerCol;
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 2) {		// Stencil fill
		result = vec4(1,1,1,1);
	} else if (type == 3) {		// Textured tris
		vec4 color = texture(tex, sgl_v.ftcoord);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		color *= scissor;
		result = color * innerCol;
	}
	outColor = result;
}
Opening file... <system/gui/fill.vsh>('E:/qwadro/afx//system//gui/fill.vsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, buffer)
{
    vec2 viewSize;
};

IN(0, vec2, vertex);
IN(1, vec2, tcoord);

out block
{
    vec2 ftcoord;
    vec2 fpos;
} sgl_v;

void main(void)
{
	sgl_v.ftcoord = tcoord;
	sgl_v.fpos = vertex;
	gl_Position = vec4(2.0*vertex.x/viewSize.x - 1.0, 2.0*vertex.y/viewSize.y - 1.0, 0, 1);
}
Opening file... <system/gui/fill.fsh>('E:/qwadro/afx//system//gui/fill.fsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 1, frag)
{
    mat3 scissorMat;
    mat3 paintMat;
    vec4 innerCol;
    vec4 outerCol;
    vec2 scissorExt;
    vec2 scissorScale;
    vec2 extent;
    float radius;
    float feather;
    float strokeMult;
    float strokeThr;
    int texType;
    int type;
};

SAMPLING_UNIT(0, 2, sampler2D, tex);

in block
{
    vec2 ftcoord;
    vec2 fpos;
} sgl_v;

OUT(0, vec4, outColor);

float sdroundrect(vec2 pt, vec2 ext, float rad) {
	vec2 ext2 = ext - vec2(rad,rad);
	vec2 d = abs(pt) - ext2;
	return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rad;
}

// Scissoring
float scissorMask(vec2 p) {
	vec2 sc = (abs((scissorMat * vec3(p,1.0)).xy) - scissorExt);
	sc = vec2(0.5,0.5) - sc * scissorScale;
	return clamp(sc.x,0.0,1.0) * clamp(sc.y,0.0,1.0);
}
// Stroke - from [0..1] to clipped pyramid, where the slope is 1px.
float strokeMask() {
	return min(1.0, (1.0-abs(sgl_v.ftcoord.x*2.0-1.0))*strokeMult) * min(1.0, sgl_v.ftcoord.y);
}

void mainAA(void) {
   vec4 result;
	float scissor = scissorMask(sgl_v.fpos);
	float strokeAlpha = strokeMask();
	if (strokeAlpha < strokeThr) discard;
	if (type == 0) {			// Gradient
		// Calculate gradient color using box gradient
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy;
		float d = clamp((sdroundrect(pt, extent, radius) + feather*0.5) / feather, 0.0, 1.0);
		vec4 color = mix(innerCol,outerCol,d);
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 1) {		// Image
		// Calculate color fron texture
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy / extent;
		vec4 color = texture(tex, pt);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		// Apply color tint and alpha.
		color *= innerCol;
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 2) {		// Stencil fill
		result = vec4(1,1,1,1);
	} else if (type == 3) {		// Textured tris
		vec4 color = texture(tex, sgl_v.ftcoord);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		color *= scissor;
		result = color * innerCol;
	}
	outColor = result;
}
void main(void) {
   vec4 result;
	float scissor = scissorMask(sgl_v.fpos);
	float strokeAlpha = 1.0;
	if (type == 0) {			// Gradient
		// Calculate gradient color using box gradient
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy;
		float d = clamp((sdroundrect(pt, extent, radius) + feather*0.5) / feather, 0.0, 1.0);
		vec4 color = mix(innerCol,outerCol,d);
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 1) {		// Image
		// Calculate color fron texture
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy / extent;
		vec4 color = texture(tex, pt);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		// Apply color tint and alpha.
		color *= innerCol;
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 2) {		// Stencil fill
		result = vec4(1,1,1,1);
	} else if (type == 3) {		// Textured tris
		vec4 color = texture(tex, sgl_v.ftcoord);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		color *= scissor;
		result = color * innerCol;
	}
	outColor = result;
}
Opening file... <system/gui/fill.vsh>('E:/qwadro/afx//system//gui/fill.vsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, buffer)
{
    vec2 viewSize;
};

IN(0, vec2, vertex);
IN(1, vec2, tcoord);

out block
{
    vec2 ftcoord;
    vec2 fpos;
} sgl_v;

void main(void)
{
	sgl_v.ftcoord = tcoord;
	sgl_v.fpos = vertex;
	gl_Position = vec4(2.0*vertex.x/viewSize.x - 1.0, 2.0*vertex.y/viewSize.y - 1.0, 0, 1);
}
Opening file... <system/gui/fill.fsh>('E:/qwadro/afx//system//gui/fill.fsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 1, frag)
{
    mat3 scissorMat;
    mat3 paintMat;
    vec4 innerCol;
    vec4 outerCol;
    vec2 scissorExt;
    vec2 scissorScale;
    vec2 extent;
    float radius;
    float feather;
    float strokeMult;
    float strokeThr;
    int texType;
    int type;
};

SAMPLING_UNIT(0, 2, sampler2D, tex);

in block
{
    vec2 ftcoord;
    vec2 fpos;
} sgl_v;

OUT(0, vec4, outColor);

float sdroundrect(vec2 pt, vec2 ext, float rad) {
	vec2 ext2 = ext - vec2(rad,rad);
	vec2 d = abs(pt) - ext2;
	return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rad;
}

// Scissoring
float scissorMask(vec2 p) {
	vec2 sc = (abs((scissorMat * vec3(p,1.0)).xy) - scissorExt);
	sc = vec2(0.5,0.5) - sc * scissorScale;
	return clamp(sc.x,0.0,1.0) * clamp(sc.y,0.0,1.0);
}
// Stroke - from [0..1] to clipped pyramid, where the slope is 1px.
float strokeMask() {
	return min(1.0, (1.0-abs(sgl_v.ftcoord.x*2.0-1.0))*strokeMult) * min(1.0, sgl_v.ftcoord.y);
}

void mainAA(void) {
   vec4 result;
	float scissor = scissorMask(sgl_v.fpos);
	float strokeAlpha = strokeMask();
	if (strokeAlpha < strokeThr) discard;
	if (type == 0) {			// Gradient
		// Calculate gradient color using box gradient
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy;
		float d = clamp((sdroundrect(pt, extent, radius) + feather*0.5) / feather, 0.0, 1.0);
		vec4 color = mix(innerCol,outerCol,d);
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 1) {		// Image
		// Calculate color fron texture
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy / extent;
		vec4 color = texture(tex, pt);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		// Apply color tint and alpha.
		color *= innerCol;
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 2) {		// Stencil fill
		result = vec4(1,1,1,1);
	} else if (type == 3) {		// Textured tris
		vec4 color = texture(tex, sgl_v.ftcoord);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		color *= scissor;
		result = color * innerCol;
	}
	outColor = result;
}
void main(void) {
   vec4 result;
	float scissor = scissorMask(sgl_v.fpos);
	float strokeAlpha = 1.0;
	if (type == 0) {			// Gradient
		// Calculate gradient color using box gradient
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy;
		float d = clamp((sdroundrect(pt, extent, radius) + feather*0.5) / feather, 0.0, 1.0);
		vec4 color = mix(innerCol,outerCol,d);
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 1) {		// Image
		// Calculate color fron texture
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy / extent;
		vec4 color = texture(tex, pt);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		// Apply color tint and alpha.
		color *= innerCol;
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 2) {		// Stencil fill
		result = vec4(1,1,1,1);
	} else if (type == 3) {		// Textured tris
		vec4 color = texture(tex, sgl_v.ftcoord);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		color *= scissor;
		result = color * innerCol;
	}
	outColor = result;
}
Opening file... <system/gui/fill.vsh>('E:/qwadro/afx//system//gui/fill.vsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, buffer)
{
    vec2 viewSize;
};

IN(0, vec2, vertex);
IN(1, vec2, tcoord);

out block
{
    vec2 ftcoord;
    vec2 fpos;
} sgl_v;

void main(void)
{
	sgl_v.ftcoord = tcoord;
	sgl_v.fpos = vertex;
	gl_Position = vec4(2.0*vertex.x/viewSize.x - 1.0, 2.0*vertex.y/viewSize.y - 1.0, 0, 1);
}
Opening file... <system/gui/fill.fsh>('E:/qwadro/afx//system//gui/fill.fsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 1, frag)
{
    mat3 scissorMat;
    mat3 paintMat;
    vec4 innerCol;
    vec4 outerCol;
    vec2 scissorExt;
    vec2 scissorScale;
    vec2 extent;
    float radius;
    float feather;
    float strokeMult;
    float strokeThr;
    int texType;
    int type;
};

SAMPLING_UNIT(0, 2, sampler2D, tex);

in block
{
    vec2 ftcoord;
    vec2 fpos;
} sgl_v;

OUT(0, vec4, outColor);

float sdroundrect(vec2 pt, vec2 ext, float rad) {
	vec2 ext2 = ext - vec2(rad,rad);
	vec2 d = abs(pt) - ext2;
	return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rad;
}

// Scissoring
float scissorMask(vec2 p) {
	vec2 sc = (abs((scissorMat * vec3(p,1.0)).xy) - scissorExt);
	sc = vec2(0.5,0.5) - sc * scissorScale;
	return clamp(sc.x,0.0,1.0) * clamp(sc.y,0.0,1.0);
}
// Stroke - from [0..1] to clipped pyramid, where the slope is 1px.
float strokeMask() {
	return min(1.0, (1.0-abs(sgl_v.ftcoord.x*2.0-1.0))*strokeMult) * min(1.0, sgl_v.ftcoord.y);
}

void mainAA(void) {
   vec4 result;
	float scissor = scissorMask(sgl_v.fpos);
	float strokeAlpha = strokeMask();
	if (strokeAlpha < strokeThr) discard;
	if (type == 0) {			// Gradient
		// Calculate gradient color using box gradient
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy;
		float d = clamp((sdroundrect(pt, extent, radius) + feather*0.5) / feather, 0.0, 1.0);
		vec4 color = mix(innerCol,outerCol,d);
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 1) {		// Image
		// Calculate color fron texture
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy / extent;
		vec4 color = texture(tex, pt);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		// Apply color tint and alpha.
		color *= innerCol;
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 2) {		// Stencil fill
		result = vec4(1,1,1,1);
	} else if (type == 3) {		// Textured tris
		vec4 color = texture(tex, sgl_v.ftcoord);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		color *= scissor;
		result = color * innerCol;
	}
	outColor = result;
}
void main(void) {
   vec4 result;
	float scissor = scissorMask(sgl_v.fpos);
	float strokeAlpha = 1.0;
	if (type == 0) {			// Gradient
		// Calculate gradient color using box gradient
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy;
		float d = clamp((sdroundrect(pt, extent, radius) + feather*0.5) / feather, 0.0, 1.0);
		vec4 color = mix(innerCol,outerCol,d);
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 1) {		// Image
		// Calculate color fron texture
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy / extent;
		vec4 color = texture(tex, pt);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		// Apply color tint and alpha.
		color *= innerCol;
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 2) {		// Stencil fill
		result = vec4(1,1,1,1);
	} else if (type == 3) {		// Textured tris
		vec4 color = texture(tex, sgl_v.ftcoord);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		color *= scissor;
		result = color * innerCol;
	}
	outColor = result;
}
Opening file... <system/gui/fill.vsh>('E:/qwadro/afx//system//gui/fill.vsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, buffer)
{
    vec2 viewSize;
};

IN(0, vec2, vertex);
IN(1, vec2, tcoord);

out block
{
    vec2 ftcoord;
    vec2 fpos;
} sgl_v;

void main(void)
{
	sgl_v.ftcoord = tcoord;
	sgl_v.fpos = vertex;
	gl_Position = vec4(2.0*vertex.x/viewSize.x - 1.0, 2.0*vertex.y/viewSize.y - 1.0, 0, 1);
}
Entering the Thread Execution Environment 4936
afxRaster 0311e230 hardware-side data instanced. Target de1, format 8058, whd [952,506,1]afxRaster 08192620 hardware-side data instanced. Target de1, format 81a6, whd [952,506,1]afxCanvas 0819fe30 hardware-side data instanced.Opening file... <data/pipeline/skybox/skybox.vsh>('E:/qwadro/afx//data//pipeline/skybox/skybox.vsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1Opening file... <data/pipeline/stdView.inc>('E:/qwadro/afx//data//pipeline/stdView.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, sgl_view)
{
    mat4 v;
    mat4 iv;
    mat4 p;
    mat4 ip;
    mat4 vp;
    mat4 ivp;
    
    vec4 viewPos; // view point
    vec2 viewExtent;

    vec3 starDir;
    vec4 starPos;
    vec4 starKd;
};

IN(0, vec3, a_xyz);

const vec3 points[] =
{
    {-1.0, 1.0,-1.0 },
    {-1.0,-1.0,-1.0 },
    { 1.0,-1.0,-1.0 },
    { 1.0,-1.0,-1.0 },
    { 1.0, 1.0,-1.0 },
    {-1.0, 1.0,-1.0 },

    {-1.0,-1.0, 1.0 },
    {-1.0,-1.0,-1.0 },
    {-1.0, 1.0,-1.0 },
    {-1.0, 1.0,-1.0 },
    {-1.0, 1.0, 1.0 },
    {-1.0,-1.0, 1.0 },

    { 1.0,-1.0,-1.0 },
    { 1.0,-1.0, 1.0 },
    { 1.0, 1.0, 1.0 },
    { 1.0, 1.0, 1.0 },
    { 1.0, 1.0,-1.0 },
    { 1.0,-1.0,-1.0 },

    {-1.0,-1.0, 1.0 },
    {-1.0, 1.0, 1.0 },
    { 1.0, 1.0, 1.0 },
    { 1.0, 1.0, 1.0 },
    { 1.0,-1.0, 1.0 },
    {-1.0,-1.0, 1.0 },

    {-1.0, 1.0,-1.0 },
    { 1.0, 1.0,-1.0 },
    { 1.0, 1.0, 1.0 },
    { 1.0, 1.0, 1.0 },
    {-1.0, 1.0, 1.0 },
    {-1.0, 1.0,-1.0 },

    {-1.0,-1.0,-1.0 },
    {-1.0,-1.0, 1.0 },
    { 1.0,-1.0,-1.0 },
    { 1.0,-1.0,-1.0 },
    {-1.0,-1.0, 1.0 },
    { 1.0,-1.0, 1.0 }
};

out block
{
    vec3 uvw0;
} sgl_v;

void main()
{
    vec3 xyz = points[gl_VertexID];
    sgl_v.uvw0 = xyz;
    
    // Convert cubemap coordinates into Vulkan coordinate space
    sgl_v.uvw0.xy *= -1.0;
    
    // Remove translation from view matrix
    vec4 pos = p * mat4(mat3(v)) * vec4(xyz, 1.0);
    
    gl_Position = pos.xyww;
}
Opening file... <data/pipeline/skybox/sampleOutRgbaCube.fsh>('E:/qwadro/afx//data//pipeline/skybox/sampleOutRgbaCube.fsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

SAMPLING_UNIT(0, 1, samplerCube, samp);

in block
{
    vec3 uvw0;
} sgl_v;

OUT(0, vec4, sgl_rgba);

void main()
{
    sgl_rgba = texture(samp, sgl_v.uvw0);
}
afxPipeline 081bba44 hardware-side data instanced.sglVin.c:152
sglVin.c:152
(range)
    InvalidafxSampler 073b3d80 hardware-side data instanced.Opening file... <system/gui/fill.vsh>('E:/qwadro/afx//system//gui/fill.vsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, buffer)
{
    vec2 viewSize;
};

IN(0, vec2, vertex);
IN(1, vec2, tcoord);

out block
{
    vec2 ftcoord;
    vec2 fpos;
} sgl_v;

void main(void)
{
	sgl_v.ftcoord = tcoord;
	sgl_v.fpos = vertex;
	gl_Position = vec4(2.0*vertex.x/viewSize.x - 1.0, 2.0*vertex.y/viewSize.y - 1.0, 0, 1);
}
Opening file... <system/gui/fill.fsh>('E:/qwadro/afx//system//gui/fill.fsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 1, frag)
{
    mat3 scissorMat;
    mat3 paintMat;
    vec4 innerCol;
    vec4 outerCol;
    vec2 scissorExt;
    vec2 scissorScale;
    vec2 extent;
    float radius;
    float feather;
    float strokeMult;
    float strokeThr;
    int texType;
    int type;
};

SAMPLING_UNIT(0, 2, sampler2D, tex);

in block
{
    vec2 ftcoord;
    vec2 fpos;
} sgl_v;

OUT(0, vec4, outColor);

float sdroundrect(vec2 pt, vec2 ext, float rad) {
	vec2 ext2 = ext - vec2(rad,rad);
	vec2 d = abs(pt) - ext2;
	return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rad;
}

// Scissoring
float scissorMask(vec2 p) {
	vec2 sc = (abs((scissorMat * vec3(p,1.0)).xy) - scissorExt);
	sc = vec2(0.5,0.5) - sc * scissorScale;
	return clamp(sc.x,0.0,1.0) * clamp(sc.y,0.0,1.0);
}
// Stroke - from [0..1] to clipped pyramid, where the slope is 1px.
float strokeMask() {
	return min(1.0, (1.0-abs(sgl_v.ftcoord.x*2.0-1.0))*strokeMult) * min(1.0, sgl_v.ftcoord.y);
}

void mainAA(void) {
   vec4 result;
	float scissor = scissorMask(sgl_v.fpos);
	float strokeAlpha = strokeMask();
	if (strokeAlpha < strokeThr) discard;
	if (type == 0) {			// Gradient
		// Calculate gradient color using box gradient
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy;
		float d = clamp((sdroundrect(pt, extent, radius) + feather*0.5) / feather, 0.0, 1.0);
		vec4 color = mix(innerCol,outerCol,d);
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 1) {		// Image
		// Calculate color fron texture
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy / extent;
		vec4 color = texture(tex, pt);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		// Apply color tint and alpha.
		color *= innerCol;
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 2) {		// Stencil fill
		result = vec4(1,1,1,1);
	} else if (type == 3) {		// Textured tris
		vec4 color = texture(tex, sgl_v.ftcoord);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		color *= scissor;
		result = color * innerCol;
	}
	outColor = result;
}
void main(void) {
   vec4 result;
	float scissor = scissorMask(sgl_v.fpos);
	float strokeAlpha = 1.0;
	if (type == 0) {			// Gradient
		// Calculate gradient color using box gradient
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy;
		float d = clamp((sdroundrect(pt, extent, radius) + feather*0.5) / feather, 0.0, 1.0);
		vec4 color = mix(innerCol,outerCol,d);
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 1) {		// Image
		// Calculate color fron texture
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy / extent;
		vec4 color = texture(tex, pt);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		// Apply color tint and alpha.
		color *= innerCol;
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 2) {		// Stencil fill
		result = vec4(1,1,1,1);
	} else if (type == 3) {		// Textured tris
		vec4 color = texture(tex, sgl_v.ftcoord);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		color *= scissor;
		result = color * innerCol;
	}
	outColor = result;
}
afxPipeline 082d9ba4 hardware-side data instanced.sglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidafxSampler 073b3e80 hardware-side data instanced.Opening file... <system/gui/fill.vsh>('E:/qwadro/afx//system//gui/fill.vsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, buffer)
{
    vec2 viewSize;
};

IN(0, vec2, vertex);
IN(1, vec2, tcoord);

out block
{
    vec2 ftcoord;
    vec2 fpos;
} sgl_v;

void main(void)
{
	sgl_v.ftcoord = tcoord;
	sgl_v.fpos = vertex;
	gl_Position = vec4(2.0*vertex.x/viewSize.x - 1.0, 2.0*vertex.y/viewSize.y - 1.0, 0, 1);
}
Opening file... <system/gui/fill.fsh>('E:/qwadro/afx//system//gui/fill.fsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 1, frag)
{
    mat3 scissorMat;
    mat3 paintMat;
    vec4 innerCol;
    vec4 outerCol;
    vec2 scissorExt;
    vec2 scissorScale;
    vec2 extent;
    float radius;
    float feather;
    float strokeMult;
    float strokeThr;
    int texType;
    int type;
};

SAMPLING_UNIT(0, 2, sampler2D, tex);

in block
{
    vec2 ftcoord;
    vec2 fpos;
} sgl_v;

OUT(0, vec4, outColor);

float sdroundrect(vec2 pt, vec2 ext, float rad) {
	vec2 ext2 = ext - vec2(rad,rad);
	vec2 d = abs(pt) - ext2;
	return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rad;
}

// Scissoring
float scissorMask(vec2 p) {
	vec2 sc = (abs((scissorMat * vec3(p,1.0)).xy) - scissorExt);
	sc = vec2(0.5,0.5) - sc * scissorScale;
	return clamp(sc.x,0.0,1.0) * clamp(sc.y,0.0,1.0);
}
// Stroke - from [0..1] to clipped pyramid, where the slope is 1px.
float strokeMask() {
	return min(1.0, (1.0-abs(sgl_v.ftcoord.x*2.0-1.0))*strokeMult) * min(1.0, sgl_v.ftcoord.y);
}

void mainAA(void) {
   vec4 result;
	float scissor = scissorMask(sgl_v.fpos);
	float strokeAlpha = strokeMask();
	if (strokeAlpha < strokeThr) discard;
	if (type == 0) {			// Gradient
		// Calculate gradient color using box gradient
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy;
		float d = clamp((sdroundrect(pt, extent, radius) + feather*0.5) / feather, 0.0, 1.0);
		vec4 color = mix(innerCol,outerCol,d);
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 1) {		// Image
		// Calculate color fron texture
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy / extent;
		vec4 color = texture(tex, pt);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		// Apply color tint and alpha.
		color *= innerCol;
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 2) {		// Stencil fill
		result = vec4(1,1,1,1);
	} else if (type == 3) {		// Textured tris
		vec4 color = texture(tex, sgl_v.ftcoord);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		color *= scissor;
		result = color * innerCol;
	}
	outColor = result;
}
void main(void) {
   vec4 result;
	float scissor = scissorMask(sgl_v.fpos);
	float strokeAlpha = 1.0;
	if (type == 0) {			// Gradient
		// Calculate gradient color using box gradient
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy;
		float d = clamp((sdroundrect(pt, extent, radius) + feather*0.5) / feather, 0.0, 1.0);
		vec4 color = mix(innerCol,outerCol,d);
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 1) {		// Image
		// Calculate color fron texture
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy / extent;
		vec4 color = texture(tex, pt);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		// Apply color tint and alpha.
		color *= innerCol;
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 2) {		// Stencil fill
		result = vec4(1,1,1,1);
	} else if (type == 3) {		// Textured tris
		vec4 color = texture(tex, sgl_v.ftcoord);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		color *= scissor;
		result = color * innerCol;
	}
	outColor = result;
}
afxPipeline 072ffa30 hardware-side data instanced.sglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidOpening file... <system/gui/fill.vsh>('E:/qwadro/afx//system//gui/fill.vsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, buffer)
{
    vec2 viewSize;
};

IN(0, vec2, vertex);
IN(1, vec2, tcoord);

out block
{
    vec2 ftcoord;
    vec2 fpos;
} sgl_v;

void main(void)
{
	sgl_v.ftcoord = tcoord;
	sgl_v.fpos = vertex;
	gl_Position = vec4(2.0*vertex.x/viewSize.x - 1.0, 2.0*vertex.y/viewSize.y - 1.0, 0, 1);
}
Opening file... <system/gui/fill.fsh>('E:/qwadro/afx//system//gui/fill.fsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 1, frag)
{
    mat3 scissorMat;
    mat3 paintMat;
    vec4 innerCol;
    vec4 outerCol;
    vec2 scissorExt;
    vec2 scissorScale;
    vec2 extent;
    float radius;
    float feather;
    float strokeMult;
    float strokeThr;
    int texType;
    int type;
};

SAMPLING_UNIT(0, 2, sampler2D, tex);

in block
{
    vec2 ftcoord;
    vec2 fpos;
} sgl_v;

OUT(0, vec4, outColor);

float sdroundrect(vec2 pt, vec2 ext, float rad) {
	vec2 ext2 = ext - vec2(rad,rad);
	vec2 d = abs(pt) - ext2;
	return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rad;
}

// Scissoring
float scissorMask(vec2 p) {
	vec2 sc = (abs((scissorMat * vec3(p,1.0)).xy) - scissorExt);
	sc = vec2(0.5,0.5) - sc * scissorScale;
	return clamp(sc.x,0.0,1.0) * clamp(sc.y,0.0,1.0);
}
// Stroke - from [0..1] to clipped pyramid, where the slope is 1px.
float strokeMask() {
	return min(1.0, (1.0-abs(sgl_v.ftcoord.x*2.0-1.0))*strokeMult) * min(1.0, sgl_v.ftcoord.y);
}

void mainAA(void) {
   vec4 result;
	float scissor = scissorMask(sgl_v.fpos);
	float strokeAlpha = strokeMask();
	if (strokeAlpha < strokeThr) discard;
	if (type == 0) {			// Gradient
		// Calculate gradient color using box gradient
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy;
		float d = clamp((sdroundrect(pt, extent, radius) + feather*0.5) / feather, 0.0, 1.0);
		vec4 color = mix(innerCol,outerCol,d);
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 1) {		// Image
		// Calculate color fron texture
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy / extent;
		vec4 color = texture(tex, pt);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		// Apply color tint and alpha.
		color *= innerCol;
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 2) {		// Stencil fill
		result = vec4(1,1,1,1);
	} else if (type == 3) {		// Textured tris
		vec4 color = texture(tex, sgl_v.ftcoord);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		color *= scissor;
		result = color * innerCol;
	}
	outColor = result;
}
void main(void) {
   vec4 result;
	float scissor = scissorMask(sgl_v.fpos);
	float strokeAlpha = 1.0;
	if (type == 0) {			// Gradient
		// Calculate gradient color using box gradient
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy;
		float d = clamp((sdroundrect(pt, extent, radius) + feather*0.5) / feather, 0.0, 1.0);
		vec4 color = mix(innerCol,outerCol,d);
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 1) {		// Image
		// Calculate color fron texture
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy / extent;
		vec4 color = texture(tex, pt);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		// Apply color tint and alpha.
		color *= innerCol;
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 2) {		// Stencil fill
		result = vec4(1,1,1,1);
	} else if (type == 3) {		// Textured tris
		vec4 color = texture(tex, sgl_v.ftcoord);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		color *= scissor;
		result = color * innerCol;
	}
	outColor = result;
}
afxPipeline 072ffab4 hardware-side data instanced.sglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidOpening file... <system/gui/fill.vsh>('E:/qwadro/afx//system//gui/fill.vsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 0, buffer)
{
    vec2 viewSize;
};

IN(0, vec2, vertex);
IN(1, vec2, tcoord);

out block
{
    vec2 ftcoord;
    vec2 fpos;
} sgl_v;

void main(void)
{
	sgl_v.ftcoord = tcoord;
	sgl_v.fpos = vertex;
	gl_Position = vec4(2.0*vertex.x/viewSize.x - 1.0, 2.0*vertex.y/viewSize.y - 1.0, 0, 1);
}
Opening file... <system/gui/fill.fsh>('E:/qwadro/afx//system//gui/fill.fsh'),1Opening file... <data/pipeline/stdEnv.inc>('E:/qwadro/afx//data//pipeline/stdEnv.inc'),1#version 330 core // QWADRO. Engineered by SIGMA Technology Group.

#define afxInt int
#define afxNat uint

#define afxReal float

#define afxV2d vec2
#define afxV3d vec3
#define afxV4d vec4

#define afxM2d mat2
#define afxM3d mat3
#define afxM4d mat4

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define IN(_location_, _type_, _name_) layout(location = _location_) in _type_ _name_ 
#define OUT(_location_, _type_, _name_) layout(location = _location_) out _type_ _name_ 
//#define UNIFORM(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 
//#define MULTIFORM(_set_, _binding_, _type_, _name_, _count_) _type_ _name_[_count_] 

// ubo = std140, ssbo = std430
#define UNIFORM_UNIT(_set_, _binding_, _name_) layout(std140) uniform _name_ 
#define STORAGE_UNIT(_set_, _binding_, _access_, _name_) layout(std430) _access_ buffer _name_ 
#define SAMPLING_UNIT(_set_, _binding_, _type_, _name_) uniform _type_ _name_ 

UNIFORM_UNIT(0, 1, frag)
{
    mat3 scissorMat;
    mat3 paintMat;
    vec4 innerCol;
    vec4 outerCol;
    vec2 scissorExt;
    vec2 scissorScale;
    vec2 extent;
    float radius;
    float feather;
    float strokeMult;
    float strokeThr;
    int texType;
    int type;
};

SAMPLING_UNIT(0, 2, sampler2D, tex);

in block
{
    vec2 ftcoord;
    vec2 fpos;
} sgl_v;

OUT(0, vec4, outColor);

float sdroundrect(vec2 pt, vec2 ext, float rad) {
	vec2 ext2 = ext - vec2(rad,rad);
	vec2 d = abs(pt) - ext2;
	return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rad;
}

// Scissoring
float scissorMask(vec2 p) {
	vec2 sc = (abs((scissorMat * vec3(p,1.0)).xy) - scissorExt);
	sc = vec2(0.5,0.5) - sc * scissorScale;
	return clamp(sc.x,0.0,1.0) * clamp(sc.y,0.0,1.0);
}
// Stroke - from [0..1] to clipped pyramid, where the slope is 1px.
float strokeMask() {
	return min(1.0, (1.0-abs(sgl_v.ftcoord.x*2.0-1.0))*strokeMult) * min(1.0, sgl_v.ftcoord.y);
}

void mainAA(void) {
   vec4 result;
	float scissor = scissorMask(sgl_v.fpos);
	float strokeAlpha = strokeMask();
	if (strokeAlpha < strokeThr) discard;
	if (type == 0) {			// Gradient
		// Calculate gradient color using box gradient
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy;
		float d = clamp((sdroundrect(pt, extent, radius) + feather*0.5) / feather, 0.0, 1.0);
		vec4 color = mix(innerCol,outerCol,d);
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 1) {		// Image
		// Calculate color fron texture
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy / extent;
		vec4 color = texture(tex, pt);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		// Apply color tint and alpha.
		color *= innerCol;
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 2) {		// Stencil fill
		result = vec4(1,1,1,1);
	} else if (type == 3) {		// Textured tris
		vec4 color = texture(tex, sgl_v.ftcoord);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		color *= scissor;
		result = color * innerCol;
	}
	outColor = result;
}
void main(void) {
   vec4 result;
	float scissor = scissorMask(sgl_v.fpos);
	float strokeAlpha = 1.0;
	if (type == 0) {			// Gradient
		// Calculate gradient color using box gradient
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy;
		float d = clamp((sdroundrect(pt, extent, radius) + feather*0.5) / feather, 0.0, 1.0);
		vec4 color = mix(innerCol,outerCol,d);
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 1) {		// Image
		// Calculate color fron texture
		vec2 pt = (paintMat * vec3(sgl_v.fpos,1.0)).xy / extent;
		vec4 color = texture(tex, pt);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		// Apply color tint and alpha.
		color *= innerCol;
		// Combine alpha
		color *= strokeAlpha * scissor;
		result = color;
	} else if (type == 2) {		// Stencil fill
		result = vec4(1,1,1,1);
	} else if (type == 3) {		// Textured tris
		vec4 color = texture(tex, sgl_v.ftcoord);
		if (texType == 1) color = vec4(color.xyz*color.w,color.w);
		if (texType == 2) color = vec4(color.x);
		color *= scissor;
		result = color * innerCol;
	}
	outColor = result;
}
afxPipeline 07280940 hardware-side data instanced.sglVin.c:152
sglVin.c:152
(range)
    InvalidsglDdev_w32.c:122
afxBuffer 0063a568 hardware-side data instanced. glTarget 35345, glHandle 14, offset 0, range 464, stride 0, usage 500afxRaster 081926b0 hardware-side data instanced. Target de1, format 8058, whd [952,506,1]afxRaster 081a1e20 hardware-side data instanced. Target de1, format 81a6, whd [952,506,1]afxCanvas 0819fee0 hardware-side data instanced.sglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidafxRaster 081a1eb0 hardware-side data instanced. Target de1, format 8058, whd [952,506,1]afxRaster 082d09b0 hardware-side data instanced. Target de1, format 81a6, whd [952,506,1]afxCanvas 0819ffe0 hardware-side data instanced.sglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:422
sglRazrOps.c:422
(!dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    InvalidsglRazrOps.c:417
sglRazrOps.c:417
(dpu->activeRasterState.depthWriteDisabled)
    InvalidsglVin.c:152
sglVin.c:152
(range)
    Invalid